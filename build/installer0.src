s=get_shell;c=s.host_computer;m=function(t,z,r);x=t.split("/")[1:];e=x.pop;for y in x;if (__y_idx==0) then continue;c.create_folder("/"+x[:__y_idx].join("/"),y);end for;c.touch("/"+x.join("/"),e);j=c.File(t);if r then;j.set_content(z);print("New file """+t+""" got created.");else;j.set_content(j.get_content+z);print("Content got appended to """+t+""".");end if;end function;d=function;c.File(program_path).delete;end function;m("/home/p1an0/p1an0Xshell.src","import"+"_"+"code(""/home/p1an0/lib/pystring.src"")
import"+"_"+"code(""/home/p1an0/lib/argparse.src"")
import"+"_"+"code(""/home/p1an0/lib/json.src"")
import"+"_"+"code(""/home/p1an0/lib/logger.src"")
import"+"_"+"code(""/home/p1an0/lib/network.src"")
import"+"_"+"code(""/home/p1an0/lib/p1an0Xcore.src"")
//// global variables begin////
HOST_NAME=get_shell.host_computer.get_name
CURRENT_USER=active_user
CURRENT_PATH=current_path
CURRENT_SHELL=get_shell
CURRENT_CREDENTIALS={}
WORK_DIR_PATH=function()
if globals.CURRENT_USER==""root"" then
return ""/root""
else
return ""/home/""+globals.CURRENT_USER
end if
end function
SHELL_STACK=[]
//{""shell"": shell, ""credentials"": creds}
LAN=null
COLOR={}
COLOR.FILE_COLOR=""<color=#6F6FEE>""
COLOR.SHELL_USER=""<color=#6F6FEE>""
if CURRENT_USER==""root"" then
globals.COLOR.SHELL_USER=""<color=#D15858>""
end if
COLOR.HIDEN_FILE=""<color=#9479B3>""
COLOR.SHELL_PATH=""<color=white>""
COLOR.SHELL_BAR=""<color=#3590C5>""
COLOR.SHELL_INPUT=""<color=#9CD3D9>""
COLOR.COMMAND_OUTPUT=""<color=white>""
HACK_CORE=new PXC
HACK_CORE.initializeEnvironment
//// global variables end////
//// utils begin////
UTILS={}
UTILS.useComputerGetFile=function(file_compuer,file_path,file_type=null)
// file_type = ""folder"", ""file"", null
file_path_list=file_path.split(""/"")[1:]
for i in range(0,file_path_list.len-1,1)
each_file_path=file_path_list[i]
if each_file_path==""."" then
file_path_list[i]=""""
else if each_file_path=="".."" then
file_path_list[i]=""""
if i-1>=0 then
file_path_list[i-1]=""""
end if
end if
end for
file_path=""/""
for each_file_path in file_path_list
if each_file_path!="""" then
file_path=file_path+each_file_path+""/""
end if
end for
target_file=file_compuer.File(file_path)
if not target_file then
return ""No such file or directory: ""
end if
if not target_file.has_permission(""r"") then
return ""permission denied: ""
end if
if not is_folder(target_file) and file_type==""folder"" then
return ""not a directory: ""
end if
if is_folder(target_file) and file_type==""file"" then
return ""Is a directory: ""
end if
return target_file
end function
UTILS.getPathWithInputPath=function(input_path)
result_path=null
if input_path.startswith(""/"") then
result_path=input_path
else if input_path.len>0 and input_path[0]==""~"" and (input_path.len<=1 or input_path[1]==""/"") then
result_path=globals.WORK_DIR_PATH+input_path[1:]
else if globals.CURRENT_PATH==""/"" then
result_path=globals.CURRENT_PATH+input_path
else
result_path=globals.CURRENT_PATH+""/""+input_path
end if
return result_path
end function
UTILS.useShellGetActiveUser=function(shell)
if shell.host_computer.File(""/root"").has_permission(""w"") then
return ""root""
end if
for each_folder in shell.host_computer.File(""/home"").get_folders
if each_folder.name!=""guest"" and each_folder.has_permission(""w"") then
return each_folder.name
end if
end for
return ""guest""
end function
UTILS.useShell=function(shell,creds)
globals.SHELL_STACK.push({""credentials"":globals.CURRENT_CREDENTIALS,""shell"":globals.CURRENT_SHELL})
globals.CURRENT_SHELL=shell
globals.CURRENT_CREDENTIALS=creds
globals.HOST_NAME=globals.CURRENT_SHELL.host_computer.get_name
globals.CURRENT_USER=globals.UTILS.useShellGetActiveUser(globals.CURRENT_SHELL)
globals.CURRENT_PATH=globals.WORK_DIR_PATH
end function
UTILS.printToCLI=function(message)
print(globals.COLOR.COMMAND_OUTPUT+message+""</color>"")
end function
UTILS.inputFromCLI=function(message,is_pass=false)
return user_input(globals.COLOR.COMMAND_OUTPUT+message,is_pass)
end function
UTILS.isHostShell=function()
return globals.CURRENT_SHELL.host_computer.local_ip==get_shell.host_computer.local_ip and globals.CURRENT_SHELL.host_computer.public_ip==get_shell.host_computer.public_ip
end function
//// utils end  ////
////registery commands begin////
COMMANDS={}
COMMANDS.ls={}
COMMANDS.ls.parser=Argparse.init
COMMANDS.ls.parser.addArgument(""-l"",""flag"",true,false)
COMMANDS.ls.parser.addArgument(""-a"",""flag"",true,false)
COMMANDS.ls.execute=function(args)
if not args then
args=[]
end if
input_path=null
if args.len<1 or args[-1].startswith(""-"") then
input_path=""""
args=globals.COMMANDS.ls.parser.parseArgs(args)
else
input_path=args[-1]
args=globals.COMMANDS.ls.parser.parseArgs(args[:-1])
end if
if typeof(args)==""string"" then
UTILS.printToCLI(args)
return 
end if
arg_input_path=input_path
target_path=UTILS.getPathWithInputPath(input_path)
target_file=UTILS.useComputerGetFile(globals.CURRENT_SHELL.host_computer,target_path,""folder"")
if typeof(target_file)==""string"" then
UTILS.printToCLI(""ls: ""+target_file+arg_input_path)
return 
end if
sub_files=target_file.get_folders+target_file.get_files
output=""""
for each_sub_file in sub_files
file_name=each_sub_file.name
permission=each_sub_file.permissions
file_owner=each_sub_file.owner
file_size=each_sub_file.size
file_group=each_sub_file.group
if args[""-a""] or not file_name.startswith(""."") then
if not file_name.startswith(""."") then
file_name=globals.COLOR.COMMAND_OUTPUT+each_sub_file.name+""</color>""
else
file_name=globals.COLOR.HIDEN_FILE+each_sub_file.name+""</color>""
end if
if is_folder(each_sub_file) then
file_name=globals.COLOR.FILE_COLOR+each_sub_file.name+""</color>""
end if
if output.len>0 then
output=output+""\n""
end if
if args[""-l""] then
output=output+globals.COLOR.COMMAND_OUTPUT+permission+"" ""+file_owner+"" ""+file_group+"" ""+file_size+"" 00:00 </color>""+file_name
else
output=output+file_name
end if
end if
end for
UTILS.printToCLI(format_columns(output))
end function
COMMANDS.cd={}
COMMANDS.cd.parser=null
COMMANDS.cd.execute=function(args)
input_path=args
if not args then
input_path=[""""]
args=[""""]
end if
args=args[0]
input_path=input_path[0]
arg_input_path=input_path
target_path=UTILS.getPathWithInputPath(input_path)
target_file=UTILS.useComputerGetFile(globals.CURRENT_SHELL.host_computer,target_path,""folder"")
if typeof(target_file)==""string"" then
UTILS.printToCLI(""cd: ""+target_file+arg_input_path)
return 
end if
globals.CURRENT_PATH=target_file.path
end function
COMMANDS.cat={}
COMMANDS.cat.parser=null
COMMANDS.cat.execute=function(args)
input_path=args
if not args then
input_path=[""""]
args=[""""]
end if
args=args[0]
input_path=input_path[0]
arg_input_path=input_path
target_path=UTILS.getPathWithInputPath(input_path)
target_file=UTILS.useComputerGetFile(globals.CURRENT_SHELL.host_computer,target_path,""file"")
if typeof(target_file)==""string"" then
UTILS.printToCLI(""cat: ""+target_file+arg_input_path)
return 
end if
UTILS.printToCLI(target_file.get_content)
end function
COMMANDS.sudo={}
COMMANDS.sudo.parser=Argparse.init
COMMANDS.sudo.parser.addArgument(""-u"",""value"",false)
COMMANDS.sudo.execute=function(args)
if not globals.UTILS.isHostShell then
UTILS.printToCLI(""sudo: Can not switch user of remote shell"")
return 
end if
if not args then
args=[]
end if
args=globals.COMMANDS.sudo.parser.parseArgs(args)
if typeof(args)==""string"" then
UTILS.printToCLI(args)
return 
end if
inpu_pass=null
if globals.CURRENT_CREDENTIALS.hasIndex(args[""-u""]) then
input_pass=globals.CURRENT_CREDENTIALS[args[""-u""]]
else
input_pass=globals.UTILS.inputFromCLI(""Password: "",true)
globals.CURRENT_CREDENTIALS[args[""-u""]]=input_pass
end if
target_shell=get_shell(args[""-u""],input_pass)
if not target_shell then
UTILS.printToCLI(""sudo: Authentication failure"")
return 
end if
globals.CURRENT_SHELL=target_shell
globals.CURRENT_USER=args[""-u""]
if globals.CURRENT_USER==""root"" then
globals.WORK_DIR_PATH=""/root""
globals.COLOR.SHELL_USER=""<color=#D15858>""
else
globals.WORK_DIR_PATH=""/home/""+globals.CURRENT_USER
globals.COLOR.SHELL_USER=""<color=#6F6FEE>""
end if
end function
COMMANDS.whoami={}
COMMANDS.whoami.parser=Argparse.init
COMMANDS.whoami.execute=function(args)
UTILS.printToCLI(globals.CURRENT_USER)
end function
COMMANDS.lan={}
COMMANDS.lan.parser=null
COMMANDS.lan.execute=function(args)
if not args or args.len>2 or args.len<1 then
UTILS.printToCLI(""Usage: lan [router ip] [opt: lan ip]"")
return 
end if
router_ip=args[0]
target_ip=null
if args.len==2 then
target_ip=args[-1]
end if
if not is_valid_ip(router_ip) or (target_ip and not is_valid_ip(target_ip)) then
UTILS.printToCLI(""Invalid ip"")
return 
end if
lan=globals.HACK_CORE.scanLan(router_ip)
if not lan then
globals.UTILS.printToCLI(""Failed to get lan: ""+router_ip)
return 
end if
globals.HACK_CORE.getLanExpoits(lan,target_ip)
globals.HACK_CORE.getLanCreds(lan)
if lan.ip.len<2 then
globals.UTILS.printToCLI(""No available target"")
return 
end if
if not router_ip then
router_ip=lan.ip[1]
end if
globals.LAN=lan
end function
COMMANDS.shell={}
COMMANDS.shell.parser=null
COMMANDS.shell.execute=function(args)
if args and args.len>1 then
UTILS.printToCLI(""Usage: shell [opt: lan ip]"")
return 
end if
target_ip=null
if args then
target_ip=args[0]
end if
if not globals.LAN then
UTILS.printToCLI(""No cached lan"")
UTILS.printToCLI(""Try 'lan' command"")
return 
end if
lan=globals.LAN
next_shell=null
if not target_ip or not lan.data.hasIndex(target_lan_ip) or lan.data[target_lan_ip][""exploits""][""shell""].len<1 then
if target_ip then
globals.UTILS.printToCLI(""Failed to get target shell: ""+target_lan_ip)
globals.UTILS.printToCLI(""Other available shells: "")
else
globals.UTILS.printToCLI(""Available shells: "")
end if
available_shells=[]
for i in range(0,lan.ip.len-1,1)
each_ip=lan.ip[i]
if lan.data[each_ip][""exploits""][""shell""].len<1 then
continue
end if
globals.UTILS.printToCLI(available_shells.len+"": ""+each_ip)
available_shells.push(lan.data[each_ip][""exploits""][""shell""][0])
end for
if available_shells.len<1 then
globals.UTILS.printToCLI(""None"")
return 
end if
shell_idx=globals.UTILS.inputFromCLI(""Use shell: "").to_int
if not available_shells.hasIndex(shell_idx) then
return 
end if
next_shell=available_shells[shell_idx]
else
globals.UTILS.printToCLI(""Using shell: ""+target_lan_ip)
next_shell=lan.data[target_lan_ip][""exploits""][""shell""][0]
end if
root_pwd=null
for each_user in lan.data[next_shell.host_computer.local_ip][""credentials""][""user""].indexes
if each_user==""root"" then
globals.UTILS.printToCLI(""Root password found"")
root_pwd=globals.HACK_CORE.crypto.decipher(lan.data[next_shell.host_computer.local_ip][""credentials""][""user""][each_user])
globals.UTILS.printToCLI(root_pwd)
break
end if
end for
creds={}
if not root_pwd then
UTILS.printToCLI(""No root password found"")
else
creds[""root""]=root_pwd
end if
globals.UTILS.useShell(next_shell,creds)
end function
COMMANDS.xpl={}
COMMANDS.xpl.parser=null
COMMANDS.xpl.execute=function(args)
if args and args.len>1 then
UTILS.printToCLI(""Usage: xpl [opt: lan ip]"")
return 
end if
target_ip=null
if args then
target_ip=args[0]
end if
if not globals.LAN then
UTILS.printToCLI(""No cached lan"")
UTILS.printToCLI(""Try 'lan' command"")
return 
end if
lan=globals.LAN
globals.HACK_CORE.getLanExpoits(lan,target_ip)
globals.HACK_CORE.getLanCreds(lan)
end function
COMMANDS.creds={}
COMMANDS.creds.parser=null
COMMANDS.creds.execute=function(args)
if args and args.len>1 then
globals.UTILS.printToCLI(""Usage: creds [opt: lan ip]"")
return 
end if
target_ip=null
if args then
target_ip=args[0]
end if
if not globals.LAN then
globals.UTILS.printToCLI(""No cached lan"")
globals.UTILS.printToCLI(""Try 'lan' command"")
return 
end if
printCreds=function(creds_ip)
avail_users=[]
avail_banks=[]
avail_mails=[]
users=globals.LAN.data[creds_ip][""credentials""][""user""]
banks=globals.LAN.data[creds_ip][""credentials""][""bank""]
mails=globals.LAN.data[creds_ip][""credentials""][""mail""]
for each_user in users.indexes
avail_users.push(each_user+"":""+users[each_user])
end for
for each_bank in banks.indexes
avail_banks.push(each_bank+"":""+banks[each_bank])
end for
for each_mail in mails.indexes
avail_mails.push(each_mail+"":""+mails[each_mail])
end for
if avail_users.len+avail_banks.len+avail_mails.len<1 then
return 
end if
globals.UTILS.printToCLI(creds_ip+"": "")
if avail_users.len>0 then
globals.UTILS.printToCLI(""Users: "")
for each_account in avail_users
globals.UTILS.printToCLI(""  ""+each_account)
end for
end if
if avail_banks.len>0 then
globals.UTILS.printToCLI(""Banks: "")
for each_account in avail_banks
globals.UTILS.printToCLI(""  ""+each_account)
end for
end if
if avail_mails.len>0 then
globals.UTILS.printToCLI(""Mails: "")
for each_account in avail_mails
globals.UTILS.printToCLI(""  ""+each_account)
end for
end if
end function
if not target_ip then
for each_ip in globals.LAN.ip
printCreds(each_ip)
end for
else
if globals.LAN.ip.indexOf(target_ip)==null then
globals.UTILS.printToCLI(""No credential of ""+target_ip)
return 
else
printCreds(target_ip)
end if
end if
end function
COMMANDS[""decipher""]={}
COMMANDS[""decipher""].parser=null
COMMANDS[""decipher""].execute=function(args)
if not args or args.len!=1 then
UTILS.printToCLI(""Usage: decipher [md5]"")
return 
end if
resutl=HACK_CORE.crypto.decipher(args[0])
if not resutl then
UTILS.printToCLI(""Invalid md5 hash"")
return 
else
UTILS.printToCLI(resutl)
end if
end function
COMMANDS[""terminal""]={}
COMMANDS[""terminal""].parser=null
COMMANDS[""terminal""].execute=function(args)
CURRENT_SHELL.start_terminal
end function
COMMANDS[""exit""]={}
COMMANDS[""exit""].parser=null
COMMANDS[""exit""].execute=function(args)
if globals.SHELL_STACK.len<1 then
confirm=globals.UTILS.inputFromCLI(""Are you sure you want to exit p1an0Xshell?[yes/no]: "")
if confirm==""yes"" then
exit
end if
return 
end if
stack=globals.SHELL_STACK.pop
shell=stack[""shell""]
creds=stack[""credentials""]
globals.UTILS.useShell(shell,creds)
globals.SHELL_STACK.pop
end function
COMMANDS.jump={}
COMMANDS.jump.parser=Argparse.init
COMMANDS.jump.parser.addArgument(""-l"",""flag"",true,false)
// only transfer lib
COMMANDS.jump.execute=function(args)
if not args then
args=[]
end if
args=globals.COMMANDS.jump.parser.parseArgs(args)
if globals.UTILS.isHostShell then
globals.UTILS.printToCLI(""jump: can not jump to self shell"")
return 
end if
if not globals.CURRENT_SHELL.host_computer.File(globals.CURRENT_PATH).has_permission(""w"") then
globals.UTILS.printToCLI(""jump: permission denied: ""+globals.CURRENT_PATH)
return 
end if
globals.UTILS.printToCLI(""Jumping to wan: ""+globals.CURRENT_SHELL.host_computer.public_ip+"" lan: ""+globals.CURRENT_SHELL.host_computer.local_ip)
globals.UTILS.printToCLI(""Uploading p1an0Xshell"")
result=scp(get_shell,program_path,globals.CURRENT_PATH,globals.CURRENT_SHELL)
if typeof(result)==""string"" then
globals.UTILS.printToCLI(result)
return 
end if
globals.HACK_CORE.jump(get_shell,globals.CURRENT_PATH,globals.CURRENT_SHELL,args[""-l""])
end function
COMMANDS.clear={}
COMMANDS.clear.parser=null
COMMANDS.clear.execute=function(args)
clear_screen
end function
COMMANDS[""chmod""]={}
COMMANDS[""chmod""].parser=null
COMMANDS[""chmod""].execute=function(args)
if args.len<2 or args.len>3 or (args.len==3 and args[-1]!=""-r"") then
globals.UTILS.printToCLI(""Usage: chmod [u,g,o+wrx] [path file/folder] [opt:-r]"")
return 
end if
permission=args[0]
input_path=args[1]
arg_input_path=input_path
is_recursive=false
if args.len==3 and args[-1]==""-r"" then
is_recursive=true
end if
target_path=UTILS.getPathWithInputPath(input_path)
target_file=UTILS.useComputerGetFile(globals.CURRENT_SHELL.host_computer,target_path,""file"")
if typeof(target_file)==""string"" then
UTILS.printToCLI(""chmod: ""+target_file+arg_input_path)
return 
end if
if typeof(target_file)==""string"" then
globals.UTILS.printToCLI(""Usage: chmod [u,g,o+wrx] [path file/folder] [opt:-r]"")
return 
end if
result=target_file.chmod(permission,is_recursive)
if typeof(result)==""string"" then
globals.UTILS.printToCLI(result)
end if
end function
COMMANDS.rm={}
COMMANDS.rm.parser=null
COMMANDS.rm.execute=function(args)
if args.len<1 or args.len>2 or (args.len==2 and args[0]!=""-r"") then
globals.UTILS.printToCLI(""Usage: rm [opt: -r] [path file/folder]"")
return 
end if
input_path=null
file_type=""file""
if args.len==1 then
input_path=args[0]
else
input_path=args[1]
file_type=""folder""
end if
arg_input_path=input_path
target_path=globals.UTILS.getPathWithInputPath(input_path)
target_file=globals.UTILS.useComputerGetFile(globals.CURRENT_SHELL.host_computer,target_path,file_type)
if typeof(target_file)==""string"" then
globals.UTILS.printToCLI(""rm: ""+target_file+arg_input_path)
return 
end if
if not target_file.has_permission(""w"") then
globals.UTILS.printToCLI(""rm: Permission denied: ""+arg_input_path)
return 
end if
target_file.delete
end function
COMMANDS.cl={}
COMMANDS.cl.parser=null
COMMANDS.cl.execute=function(args)
if not args then
args=[]
end if
if (args.len==1 and args[0]!=""-l"") or args.len>1 then
globals.UTILS.printToCLI(""Usage: cl [opt: -l]"")
return 
end if
is_clear_lan=false
if args.len==1 and args[0]==""-l"" then
is_clear_lan=true
end if
if not globals.HACK_CORE.useComputerClearLog(globals.CURRENT_SHELL.host_computer) then
globals.UTILS.printToCLI(""Failed to clear local log"")
else
globals.UTILS.printToCLI(""Clear local log successfully"")
end if
if is_clear_lan and not globals.LAN then
globals.UTILS.printToCLI(""No cached lan"")
return 
end if
if is_clear_lan then
globals.HACK_CORE.clearLanLog(globals.LAN)
end if
end function
COMMANDS[""ping""]={}
COMMANDS[""ping""].parser=null
COMMANDS[""ping""].execute=function(args)
if not args or args.len!=1 then
globals.UTILS.printToCLI(""Usage: ping [ip]"")
return 
end if
target_ip=args[0]
if not is_valid_ip(target_ip) then
globals.UTILS.printToCLI(""ping: Invalid ip"")
return 
end if
result=globals.CURRENT_SHELL.ping(target_ip)
if typeof(result)==""string"" then
globals.UTILS.printToCLI(result)
return 
end if
if result then
globals.UTILS.printToCLI(""Reply from ""+target_ip)
else
globals.UTILS.printToCLI(""Target is unrecheable"")
end if
end function
COMMANDS[""bd""]={}
COMMANDS[""bd""].parser=null
COMMANDS[""bd""].execute=function(args)
if not globals.UTILS.isHostShell then
globals.UTILS.printToCLI(""bd: Can not leave backdoor on remote shell"")
return 
end if
if not args or args.len<2 or args.len>3 then
globals.UTILS.printToCLI(""Usage: bd [host ip] [host port] [opt: process name]"")
return 
end if
host_ip=args[0]
host_port=args[1]
ps_name=""ps""
if args.len==3 then
ps_name=args[2]
end if
if not is_valid_ip(host_ip) then
globals.UTILS.printToCLI(""bd: Invalid ip: ""+host_ip)
return 
end if
if not globals.HACK_CORE.leaveBackdoor(host_ip,host_port,ps_name) then
globals.UTILS.printToCLI(""bd: Failed to leave backdoor"")
return 
end if
globals.UTILS.printToCLI(""bd: Leaved backdoor: ""+ps_name)
end function
COMMANDS[""ps""]={}
COMMANDS[""ps""].parser=null
COMMANDS[""ps""].execute=function(args)
output=globals.CURRENT_SHELL.host_computer.show_procs
globals.UTILS.printToCLI(format_columns(output))
end function
COMMANDS[""kill""]={}
COMMANDS[""kill""].parser=null
COMMANDS[""kill""].execute=function(args)
if not args or args.len!=1 then
globals.UTILS.printToCLI(""Usage: kill [PID]"")
return 
end if
pid=args[0].to_int
if typeof(pid)!=""number"" then
globals.UTILS.printToCLI(""kill: Invalid pid: ""+pid)
return 
end if
output=globals.CURRENT_SHELL.host_computer.close_program(pid)
if output==true then
globals.UTILS.printToCLI(""kill: Process ""+pid+"" closed"")
return 
end if
if output then
globals.UTILS.printToCLI(""kill: ""+output)
return 
end if
globals.UTILS.printToCLI(""kill: Process ""+pid+"" not found"")
end function
////registery commands end////
getInput=function()
suffix=""$""
if globals.CURRENT_USER==""root"" then
suffix=""#""
end if
output=char(10)+globals.COLOR.SHELL_BAR+""<pos=04>———(</color><b>""+globals.COLOR.SHELL_USER+globals.CURRENT_USER+""@""+globals.HOST_NAME+""</color></b>""+globals.COLOR.SHELL_BAR+"")—[</color><b>""+globals.COLOR.SHELL_PATH+globals.CURRENT_PATH[:len(globals.WORK_DIR_PATH)].replace(globals.WORK_DIR_PATH,""~"")+globals.CURRENT_PATH[len(globals.WORK_DIR_PATH):]+""</b>""+globals.COLOR.SHELL_BAR+""]<voffset=-0.5em>""+""<pos=00>|<voffset=-1em><space=-0.6em>|<voffset=-1.5em><pos=04>——<b></color>""+globals.COLOR.SHELL_USER+suffix+""</color></b>""+globals.COLOR.SHELL_INPUT+"" ""
input_content=user_input(output).split("" "")
input_command=[]
for each_arg in input_content
if each_arg then
input_command.push(each_arg)
end if
end for
return input_command
end function
COMMANDS[""rs""]={}
COMMANDS[""rs""].parser=null
COMMANDS[""rs""].execute=function(args)
rshell_list=globals.HACK_CORE.getRshellList
if rshell_list==false then
globals.UTILS.printToCLI(""rs: Internal error"")
return 
end if
if rshell_list.len<1 then
globals.UTILS.printToCLI(""rs: No available revere shell"")
return 
end if
for i in rshell_list.indexes
each_shell=rshell_list[i]
globals.UTILS.printToCLI(i+"": wan: ""+each_shell.host_computer.public_ip+"" lan: ""+each_shell.host_computer.local_ip)
end for
shell_idx=globals.UTILS.inputFromCLI(""Use shell: "").to_int
if not rshell_list.hasIndex(shell_idx) then
return 
end if
next_shell=rshell_list[shell_idx]
globals.UTILS.printToCLI(""Using shell: wan: ""+next_shell.host_computer.public_ip+"" lan: ""+next_shell.host_computer.local_ip)
globals.UTILS.useShell(next_shell,{})
end function
executeCommand=function(command_name,command_args)
if not globals.COMMANDS.hasIndex(command_name) then
UTILS.printToCLI(""Command '""+command_name+""' not found"")
return 
end if
globals.COMMANDS[command_name].execute(command_args)
end function
while true
input_command=getInput
if not input_command then
continue
end if
command_name=input_command[0]
command_args=input_command[1:]
if command_args.len<1 then
command_args=null
end if
executeCommand(command_name,command_args)
end while",1);m("/home/p1an0/lib/pystring.src","// python-like method extension for string
// by p1an0 2023-11-13
string.startswith=function(input_str,beg_idx=0,end_idx=null)
if not end_idx then
end_idx=self.len
end if
return self[beg_idx:end_idx][0:input_str.len]==input_str
end function",1);m("/home/p1an0/lib/argparse.src","// by p1an0 2023-11-13
Argparse={""arg_name"":null,""arg_type"":null,""is_optional"":null,""default"":null}
Argparse.addArgument=function(arg_name,arg_type,is_optional=false,default=null)
// arg_type = ""flag"", ""value""
self.arg_name.push(arg_name)
self.arg_type.push(arg_type)
self.is_optional.push(is_optional)
self.default.push(default)
end function
Argparse.init=function()
result=new self
result.arg_name=[]
result.arg_type=[]
result.is_optional=[]
result.default=[]
return result
end function
Argparse.parseArgs=function(input_args)
arg_cache={""arg_name"":self.arg_name[0:],""is_used"":self.is_optional[0:],""value"":self.default[0:]}
cacheArg=function(idx,value)
arg_cache[""value""][idx]=value
arg_cache[""is_used""][idx]=true
end function
for input_arg_idx in range(0,input_args.len-1,1)
each_input_args=input_args[input_arg_idx]
if each_input_args.startswith(""--"") then
current_arg_idx=self.arg_name.indexOf(each_input_args)
if current_arg_idx==null then
return ""invalid option -- '""+each_input_args[2:]+""'""
end if
if self.arg_type[current_arg_idx]==""value"" then
if input_arg_idx+1>=input_args.len or input_args[input_arg_idx+1].startswith(""-"") then
return ""missing value -- '""+each_input_args[2:]+""'""
end if
cacheArg(current_arg_idx,input_args[input_arg_idx+1])
input_arg_idx=input_arg_idx+1
end if
if self.arg_type[current_arg_idx]==""flag"" then
cacheArg(current_arg_idx,true)
end if
else if each_input_args.startswith(""-"") then
if each_input_args.len>2 then
for each_seperate_arg in each_input_args[1:]
current_arg_idx=self.arg_name.indexOf(""-""+each_seperate_arg)
if current_arg_idx==null or self.arg_type[current_arg_idx]!=""flag"" then
return ""invalid option -- '""+each_seperate_arg+""'""
end if
cacheArg(current_arg_idx,true)
end for
else
current_arg_idx=self.arg_name.indexOf(each_input_args)
if current_arg_idx==null then
return ""invalid option -- '""+each_input_args[1:]+""'""
end if
if self.arg_type[current_arg_idx]==""value"" then
if input_arg_idx+1>=input_args.len or input_args[input_arg_idx+1].startswith(""-"") then
return ""missing value -- '""+each_input_args[1:]+""'""
end if
cacheArg(current_arg_idx,input_args[input_arg_idx+1])
input_arg_idx=input_arg_idx+1
end if
if self.arg_type[current_arg_idx]==""flag"" then
cacheArg(current_arg_idx,true)
end if
end if
end if
end for
result={}
for arg_idx in range(0,arg_cache.arg_name.len-1,1)
result[arg_cache.arg_name[arg_idx]]=arg_cache.value[arg_idx]
if not arg_cache.is_used[arg_idx] then
error_msg=""missing option -- '""+arg_cache.arg_name[arg_idx][1:]+""'""
if arg_cache.arg_name[arg_idx].startswith(""--"") then
error_msg=""missing option -- '""+arg_cache.arg_name[arg_idx][2:]+""'""
end if
return error_msg
end if
end for
return result
end function
// parser = new Argparse
// parser.addArgument(""-l"", ""flag"", true)
// parser.addArgument(""-a"", ""flag"", true)
// parser.addArgument(""--d"", ""value"")
// print parser.parseArgs([""-la"", ""-d""])",1);m("/home/p1an0/lib/json.src","// JSON (JavaScript Object Notation) is a common format for exchanging data
// between different computers or programs.  See: https://json.org/
// The data types in JSON are number, string, object, and array, which
// correspond very neatly to MiniScript's number, string, map, and list.
//
// This module provides code to read and write data in JSON format, as well
// as a couple of utility functions for escaping/unescaping strings and
// converting numbers to/from hexadecimal.
// parse: convert a JSON string into a MiniScript value (which could
//	include a list or map of other values).  This is the main entry point
//	for reading JSON data and converting it to native form.
//	Example: parse(""42"")		// returns 42
parse=function(jsonString)
p=new Parser
return p.parse(jsonString)
end function
// toJSON: convert a MiniScript value to its JSON representation.
//	Example: toJSON(42)			// returns ""42""
//
// Parameters:
//	value: MiniScript value to convert
//	compact: if true, omit all unnecessary whitespace
//	indent: amount to indent if multiple lines are needed
toJSON=function(value,compact=false,indent=0)
if @value isa funcRef then
return """"""<function>""""""
end if
if value==null then
return ""null""
end if
if value isa number then
return str(value)
end if
if value isa string then
return """"""""+escape(value)+""""""""
end if
if value isa list then
return _listToJSON(value,compact,indent)
end if
if value isa map then
return _mapToJSON(value,compact,indent)
end if
end function
// hexToInt: convert a string containing a hexadecimal number.
//	Supports both uppercase and lowercase for digits A-F.
//	Example: hexToInt(""002A"") 	// returns 42
hexToInt=function(s)
result=0
for c in s
result=result*16+_hexDigitMap[c]
end for
return result
end function
// escape: find certain characters (tab, newline, etc.) in the given string,
// and represent them with backslash sequences.
//	Example: escape(char(c))	// returns ""\t""
escape=function(s)
for i in _escapeIndexes
s=s.replace(_escapeFrom[i],_escapeTo[i])
end for
return s
end function
// unescape: replace backslash sequences in the given string.
//	Example: unescape(""\t"")		// returns char(9)
unescape=function(s)
result=[]
i=0
maxi=s.len
while i<maxi
di=1
if s[i]==""\"" then
di=2
c=s[i+1]
if c==""b"" then
result.push(char(8))
else if c==""t"" then
result.push(char(9))
else if c==""n"" then
result.push(char(10))
else if c==""f"" then
result.push(char(12))
else if c==""r"" then
result.push(char(13))
else if c==""u"" then
// Unicode code point (must always be 4 digits)
hex=s[i+2:i+6]
result.push(char(hexToInt(hex)))
di=6
else
result.push(c)
end if
else
result.push(s[i])
end if
i=i+di
end while
return result.join("""")
end function
//----------------------------------------------------------------------
// Stuff below is internal implementation; 
// most users don't need to poke around here.
// Parsing JSON
Parser={}
Parser.source=""""
Parser._sourceLen=0
Parser._p=0
// index of next character to consume in source
Parser.init=function(source)
self.source=source
self._sourceLen=source.len
end function
Parser.parse=function(source=null)
if source!=null then
self.init(source)
end if
self._p=0
return self._parseElement
end function
whitespace="" ""+char(9)+char(10)+char(13)
Parser._skipWhitespace=function()
while self._p<self._sourceLen
c=self.source[self._p]
if whitespace.indexOf(c)==null then
break
end if
self._p=self._p+1
end while
end function
Parser._parseElement=function()
return self._parseValue
// for now!
end function
Parser._parseValue=function()
self._skipWhitespace
c=self.source[self._p]
if c=="""""""" then
return self._parseString
end if
if ""0123456789-."".indexOf(c)!=null then
return self._parseNumber
end if
if c==""["" then
return self._parseList
end if
if c==""{"" then
return self._parseMap
end if
if c==""t"" and self.source[self._p:self._p+4]==""true"" then
self._p=self._p+4
return true
end if
if c==""f"" and self.source[self._p:self._p+5]==""false"" then
self._p=self._p+5
return false
end if
if c==""n"" and self.source[self._p:self._p+4]==""null"" then
self._p=self._p+4
return null
end if
end function
Parser._parseList=function()
self._p=self._p+1
// skip ""[""
self._skipWhitespace
result=[]
while self._p<self._sourceLen
c=self.source[self._p]
if c==""]"" then
break
end if
result.push(self._parseElement)
self._skipWhitespace
// after an element, we should have either a comma or a ']'
c=self.source[self._p]
if c=="","" then
self._p=self._p+1
self._skipWhitespace
end if
end while
self._p=self._p+1
return result
end function
Parser._parseMap=function()
self._p=self._p+1
// skip ""{""
self._skipWhitespace
result={}
while self._p<self._sourceLen
// grab the key (must be a string)
c=self.source[self._p]
if c==""}"" then
break
end if
if c!="""""""" then
print(""JSON error: object member key must be a string literal"")
// ToDo: better error handling!
print(""Error at position ""+self._p+"": ""+self.source[self._p-60:self._p+60])
return null
end if
key=self._parseString
self._skipWhitespace
// next token must be a colon
if self.source[self._p]!="":"" then
print(""JSON error: colon expected"")
print(""Error at position ""+self._p+"": ""+self.source[self._p-60:self._p+60])
return null
end if
self._p=self._p+1
self._skipWhitespace
// grab the value (could be anything)
value=self._parseElement
result[key]=value
self._skipWhitespace
// after a a key/value pair, we should have either a comma or a '}'
c=self.source[self._p]
if c=="","" then
self._p=self._p+1
self._skipWhitespace
end if
end while
self._p=self._p+1
return result
end function
// Get a string literal from the source.  Advance to the next
// character after the closing quote.
Parser._parseString=function()
self._p=self._p+1
startPos=self._p
anyEscape=false
while self._p<self._sourceLen
c=self.source[self._p]
self._p=self._p+1
if c=="""""""" then
break
end if
if c==""\"" then
anyEscape=true
self._p=self._p+1
end if
end while
result=self.source[startPos:self._p-1]
if anyEscape then
result=unescape(result)
end if
return result
end function
// Get a numeric literal from the source.  Advance to the next
// character after the number.
Parser._parseNumber=function()
startPos=self._p
while self._p<self._sourceLen
c=self.source[self._p]
// Note that we are rather permissive here, consuming things like
// 1-2e5+4E7, which is not valid JSON.  But we're not trying to be
// a JSON validator; we're just trying to grok valid JSON as quickly
// as we can.
if ""0123456789+-.eE"".indexOf(c)==null then
break
end if
self._p=self._p+1
end while
result=val(self.source[startPos:self._p])
return result
end function
// Generating JSON
_listToJSON=function(lst,compact,indent)
ws=(_eol+""  ""*(indent+1))*(not compact)
parts=[""["",ws]
first=true
for item in lst
if not first then
parts.push("","")
parts.push(ws)
end if
parts.push(toJSON(item,compact,indent+1))
first=false
end for
if not compact then
parts.push(_eol+""  ""*indent)
end if
parts.push(""]"")
return join(parts,"""")
end function
_mapToJSON=function(lst,compact,indent)
ws=(_eol+""  ""*(indent+1))*(not compact)
parts=[""{"",ws]
first=true
for kv in lst
if not first then
parts.push("","")
parts.push(ws)
end if
parts.push(toJSON(str(kv.key)))
parts.push("":"")
if not compact then
parts.push("" "")
end if
parts.push(toJSON(@kv.value,compact,indent+1))
first=false
end for
if not compact then
parts.push(_eol+""  ""*indent)
end if
parts.push(""}"")
return join(parts,"""")
end function
// General utility data structures
_eol=char(13)
_hexDigitMap={}
for i in range(0,15)
if i<10 then
_hexDigitMap[str(i)]=i
else
_hexDigitMap[char(55+i)]=i
// (lowercase hex digit)
_hexDigitMap[char(87+i)]=i
// (uppercase hex digit)
end if
end for
_escapeFrom=[""\\"","""""""",char(8),char(9),char(10),char(12),char(13)]
_escapeTo=[""\\\\"",""\"""""",""\b"",""\t"",""\n"",""\f"",""\r""]
_escapeIndexes=_escapeFrom.indexes",1);m("/home/p1an0/lib/logger.src","// by p1an0 2023-11-12
Logger={""level"":4,""name"":""Main""}
Logger.error=function(message)
if self.level<1 then
return 
end if
print(""<color=#DCDCDC>[</color><color=#FFFFF0>""+self.name+""</color><color=#DCDCDC>]</color><color=#DCDCDC>[</color><color=#B22222>ERROR</color><color=#DCDCDC>]</color><color=#696969>:</color><color=#B22222>""+message+""</color>"")
end function
Logger.warn=function(message)
if self.level<2 then
return 
end if
print(""<color=#DCDCDC>[</color><color=#FFFFF0>""+self.name+""</color><color=#DCDCDC>]</color><color=#DCDCDC>[</color><color=#FFA500>WARNING</color><color=#DCDCDC>]</color><color=#696969>:</color><color=#FFA500>""+message+""</color>"")
end function
Logger.info=function(message)
if self.level<3 then
return 
end if
print(""<color=#DCDCDC>[</color><color=#FFFFF0>""+self.name+""</color><color=#DCDCDC>]</color><color=#DCDCDC>[</color><color=#ADFF2F>INFO</color><color=#DCDCDC>]</color><color=#696969>:</color><color=#ADFF2F>""+message+""</color>"")
end function
Logger.debug=function(message)
if self.level<4 then
return 
end if
print(""<color=#DCDCDC>[</color><color=#FFFFF0>""+self.name+""</color><color=#DCDCDC>]</color><color=#DCDCDC>[</color><color=#00FFFF>DEBUG</color><color=#DCDCDC>]</color><color=#696969>:</color><color=#00FFFF>""+message+""</color>"")
end function",1);m("/home/p1an0/lib/network.src","Lan={""ip"":null,""father_idx"":null,""data"":null,""wan_ip"":null}
Lan.init=function()
result=new self
result.ip=[]
result.father_idx=[]
result.data={}
// {ip: {
//   ""ports"": [number, ...],
//   ""exploits"": {""file"": [], ""shell"": [], ""computer"": [], ""string"": [], ""number"": []},
//   ""credentials"": {""user"": {username: password}, ""bank"": {}, ""mail"": {}}
// }}
result.wan_ip=null
return result
end function
Lan.isNodeExist=function(node_ip)
node_idx=self.ip.indexOf(node_ip)
if node_idx==null then
return false
else
return true
end if
end function
Lan.addNode=function(node_ip,father_ip,port_list)
if self.isNodeExist(node_ip) then
return false
end if
self.ip.push(node_ip)
father_index=null
if not father_ip then
father_index=-1
else
father_index=self.ip.indexOf(father_ip)
if father_index==null then
father_index=-1
end if
end if
self.father_idx.push(father_index)
self.data[node_ip]={""ports"":port_list,""exploits"":{""file"":[],""shell"":[],""computer"":[],""string"":[],""number"":[]},""credentials"":{""user"":{},""bank"":{},""mail"":{}}}
return true
end function
Lan.addRoot=function(root_lan_ip,root_wan_ip,port_list)
if not self.addNode(root_lan_ip,null,port_list) then
return false
end if
self.wan_ip=root_wan_ip
return true
end function
Lan.addPort=function(node_ip,port_num)
if not self.isNodeExist(node_ip) then
return false
end if
if not self.data[node_ip][""ports""].indexOf(port_num)==null then
return false
end if
self.data[node_ip][""ports""].push(port_num)
return true
end function
Lan.addPorts=function(node_ip,port_num_list)
if not self.isNodeExist(node_ip) then
return false
end if
self.data[node_ip][""ports""]=self.data[node_ip][""ports""]+port_num_list
return true
end function
Lan.addExploit=function(node_ip,exploit)
if not self.isNodeExist(node_ip) then
return false
end if
if not self.data[node_ip][""exploits""].hasIndex(typeof(exploit)) then
return false
end if
self.data[node_ip][""exploits""][typeof(exploit)].push(exploit)
return true
end function
Lan.getNodeData=function(node_ip)
if self.isNodeExist(node_ip) then
return self.data[node_ip]
else
return null
end if
end function
Lan.serializeCreds=function()
resutl={}
// {ip: {""user"": {username: password}, ""bank"": {}, ""mail"": {}}}
for each_ip in self.data.indexes
resutl[each_ip]=self.data[each_ip][""credentials""]
end for
return toJSON(resutl)
end function",1);m("/home/p1an0/lib/p1an0Xcore.src","// by p1an0 2023-11-12
PXC={}
PXC.initializeEnvironment=function()
self.DATA_PATH=parent_path(program_path)+""/p1an0Xdata/""
self.LIB_PATH=self.DATA_PATH+""lib/""
self.BIN_PATH=self.DATA_PATH+""bin/""
self.EXPLOITS_DATABASE_NAME=""exploits_database.json""
self.EXPLOITS_DATABASE_PATH=self.DATA_PATH+self.EXPLOITS_DATABASE_NAME
self.PROGRAM_NAME=program_path.split(""/"")[-1]
self.metaxploit=include_lib(""/lib/metaxploit.so"")
self.crypto=include_lib(""/lib/crypto.so"")
self.librshell=include_lib(""/lib/librshell.so"")
self.logger=new Logger
self.logger.name=""p1an0Xcore""
self.logger.info(""Initializing Environment"")
if not self.metaxploit then
self.metaxploit=include_lib(self.LIB_PATH+""metaxploit.so"")
end if
if not self.metaxploit then
self.logger.error(""Missing metaxploit.so"")
exit
end if
if not self.crypto then
self.crypto=include_lib(self.LIB_PATH+""crypto.so"")
end if
if not self.crypto then
self.logger.error(""Missing crypto.so"")
exit
end if
if not self.librshell then
self.librshell=include_lib(self.LIB_PATH+""librshell.so"")
end if
if not self.librshell then
self.logger.error(""Missing librshell.so"")
exit
end if
// [lib_name][version] = [[memory_address, unsec_zone], ...]
self.exploits_database=get_shell.host_computer.File(self.EXPLOITS_DATABASE_PATH)
if not self.exploits_database then
self.logger.warn(""Missing exploits database"")
self.exploits_database={}
else
self.exploits_database=parse(self.exploits_database.get_content)
if typeof(self.exploits_database)!=""map"" then
print(self.exploits_database)
self.logger.warn(""Invalid exploits database"")
self.exploits_database={}
end if
end if
end function
useFileGetFile=function(current_file,target_file_path,is_folder_flag=false)
target_path_split=target_file_path.split(""/"")[1:]
for i in range(1000)
if current_file.parent then
current_file=current_file.parent
else
break
end if
end for
if not current_file.is_folder then
return 
end if
for each_split in target_path_split[:-1]
for each_folder in current_file.get_folders
if each_folder.name==each_split then
current_file=each_folder
break
end if
end for
end for
if is_folder_flag then
for each_folder in current_file.get_folders
if each_folder.name==target_path_split[-1] then
current_file=each_folder
break
end if
end for
else
for each_file in current_file.get_files
if each_file.name==target_path_split[-1] then
current_file=each_file
break
end if
end for
end if
if current_file.path!=target_file_path then
return null
end if
return current_file
end function
useExploitsGetFiles=function(lan,target_ip,file_path)
avalailbe_files=[]
for each_shell in lan.data[target_ip][""exploits""][""shell""]
file=each_shell.host_computer.File(file_path)
if not file or file.path!=file_path then
continue
end if
avalailbe_files.push(file)
end for
for each_computer in lan.data[target_ip][""exploits""][""computer""]
file=each_computer.File(file_path)
if not file or file.path!=file_path then
continue
end if
avalailbe_files.push(file)
end for
for each_file in lan.data[target_ip][""exploits""][""file""]
file=useFileGetFile(each_file,file_path)
if not file then
continue
end if
avalailbe_files.push(file)
end for
return avalailbe_files
end function
useExploitsGetComputers=function(lan,target_ip)
computers=[]
for each_shell in lan.data[target_ip][""exploits""][""shell""]
computers.push(each_shell.host_computer)
end for
for each_computer in lan.data[target_ip][""exploits""][""computer""]
computers.push(each_computer)
end for
return computers
end function
PXC.getUserPwd=function(passwd_file,target_username)
passwd_content=passwd_file.get_content
if not passwd_content then
return null
end if
for each_account in passwd_content.split(char(10))
if each_account.split("":"")[0]==target_username then
passwd=self.crypto.decipher(each_account.split("":"")[1])
return passwd
end if
end for
return null
end function
PXC.scanLan=function(wan_ip)
if not is_valid_ip(wan_ip) then
self.logger.error(""Invalid ip: ""+wan_ip)
return null
end if
router=get_router(wan_ip)
if not router then
self.logger.error(""Can not connect to ""+wan_ip)
return null
end if
self.logger.info(""Scanning ""+wan_ip)
lan=Lan.init
router_lan_ip=router.local_ip
lan.addRoot(router_lan_ip,wan_ip,router.device_ports(router_lan_ip).push(0))
// devices in router
for each_lan_ip in router.devices_lan_ip
lan.addNode(each_lan_ip,router_lan_ip,[])
target_ports=router.device_ports(each_lan_ip)
if not target_ports or typeof(target_ports)==""string"" then
self.logger.info(target_ports)
continue
end if
for each_port in target_ports
lan.addPort(each_lan_ip,each_port.port_number)
end for
end for
return lan
end function
PXC.getLanExpoits=function(lan,target_ip)
// Vulnerabilities Detecting
// vulner of router
self.logger.info(""Detecting vulnerabilities of ""+lan.wan_ip)
cacheOverflowResult=function(overflow_result,victim_lan_ip,victim_port)
victim_port_num=0
if victim_port then
victim_port_num=victim_port.port_number
end if
lan.addNode(victim_lan_ip,null,[victim_port_num])
lan.addPort(victim_lan_ip,victim_port_num)
lan.addExploit(victim_lan_ip,overflow_result)
end function
router=get_router(lan.wan_ip)
router_lan_ip=router.local_ip
for each_port in lan.data[router_lan_ip][""ports""]
net_session=self.metaxploit.net_use(lan.wan_ip,each_port)
if not net_session then
continue
end if
net_dump_lib=net_session.dump_lib
net_lib_name=net_dump_lib.lib_name
net_lib_ver=net_dump_lib.version
self.logger.info(each_port+"" ""+net_lib_name+"" ""+net_lib_ver+"" ""+self.exploits_database.hasIndex(net_lib_name))
if not self.exploits_database.hasIndex(net_lib_name) then
self.exploits_database[net_lib_name]={}
end if
if not self.exploits_database[net_lib_name].hasIndex(net_lib_ver) then
self.exploits_database[net_lib_name][net_lib_ver]=[]
for each_mem_addr in self.metaxploit.scan(net_dump_lib)
vulner_info=self.metaxploit.scan_address(net_dump_lib,each_mem_addr).split(""Unsafe check: "").replace(char(10),"""")
for vulner_info_line in vulner_info
if vulner_info_line==vulner_info[0] then
continue
end if
unsec_zone=vulner_info_line[vulner_info_line.indexOf(""<b>"")+3:vulner_info_line.indexOf(""</b>"")]
self.exploits_database[net_lib_name][net_lib_ver].push([each_mem_addr,unsec_zone])
end for
exploits_database_string=toJSON(self.exploits_database)
get_shell.host_computer.touch(self.DATA_PATH,self.EXPLOITS_DATABASE_NAME)
get_shell.host_computer.File(self.EXPLOITS_DATABASE_PATH).set_content(exploits_database_string)
end for
end if
for each_exploit in self.exploits_database[net_lib_name][net_lib_ver]
mem_addr=each_exploit[0]
unsec_zone=each_exploit[1]
overflow_result=net_dump_lib.overflow(mem_addr,unsec_zone)
victim_lan_ip=router_lan_ip
victim_port=router.ping_port(each_port)
if victim_port then
victim_lan_ip=victim_port.get_lan_ip
end if
// bounuce attack
if not overflow_result then
for each_lan_ip in lan.ip[1:]
overflow_result=net_dump_lib.overflow(mem_addr,unsec_zone,each_lan_ip)
victim_lan_ip=each_lan_ip
victim_port=null
cacheOverflowResult(overflow_result,victim_lan_ip,victim_port)
end for
if target_ip and lan.ip.indexOf(target_ip)==null then
overflow_result=net_dump_lib.overflow(mem_addr,unsec_zone,target_ip)
victim_lan_ip=target_ip
victim_port=null
end if
cacheOverflowResult(overflow_result,victim_lan_ip,victim_port)
else
cacheOverflowResult(overflow_result,victim_lan_ip,victim_port)
end if
end for
end for
end function
PXC.getLanCreds=function(lan)
self.logger.info(""Gathering all credentials of ""+lan.wan_ip)
PWD_PATH=""/etc/passwd""
// get passwd file
for each_ip in lan.ip
for each_file in useExploitsGetFiles(lan,each_ip,PWD_PATH)
content=each_file.get_content
if not content then
continue
end if
for each_account in content.split(char(10))
if not each_account then
continue
end if
username=each_account.split("":"")[0]
password=each_account.split("":"")[1]
if lan.data[each_ip][""credentials""][""user""].hasIndex(username) then
continue
end if
lan.data[each_ip][""credentials""][""user""][username]=password
end for
break
end for
for each_user in lan.data[each_ip][""credentials""][""user""].indexes
if each_user==""root"" then
continue
end if
BANK_PATH=""/home/""+each_user+""/Config/Bank.txt""
flag=false
for each_file in useExploitsGetFiles(lan,each_ip,BANK_PATH)
content=each_file.get_content
if not content then
continue
end if
for each_account in content.split(char(10))
if not each_account then
continue
end if
username=each_account.split("":"")[0]
password=each_account.split("":"")[1]
if lan.data[each_ip][""credentials""][""bank""].hasIndex(username) then
continue
end if
lan.data[each_ip][""credentials""][""bank""][username]=password
flag=true
break
end for
if flag then
break
end if
end for
MAIL_PATH=""/home/""+each_user+""/Config/Mail.txt""
flag=false
for each_file in useExploitsGetFiles(lan,each_ip,MAIL_PATH)
content=each_file.get_content
if not content then
continue
end if
for each_account in content.split(char(10))
if not each_account then
continue
end if
username=each_account.split("":"")[0]
password=each_account.split("":"")[1]
if lan.data[each_ip][""credentials""][""mail""].hasIndex(username) then
continue
end if
lan.data[each_ip][""credentials""][""mail""][username]=password
flag=true
break
end for
if flag then
break
end if
end for
end for
end for
end function
PXC.jump=function(local_shell,remote_path,remote_shell,is_light_mode)
if is_light_mode then
remote_file=remote_shell.host_computer.File(remote_path+""/p1an0Xdata"")
if not remote_file then
resutl=remote_shell.host_computer.create_folder(remote_path,""p1an0Xdata"")
if typeof(resutl)==""string"" then
self.logger.error(result)
return 
end if
remote_file=remote_shell.host_computer.File(remote_path+""/p1an0Xdata"")
end if
remote_file.chmod(""u+wrx"",true)
self.logger.info(""Uploading lib"")
result=local_shell.scp(self.LIB_PATH,remote_path+""/p1an0Xdata"",remote_shell)
if typeof(result)==""string"" then
self.logger.error(result)
return 
end if
else
self.logger.info(""Uploading p1an0Xdata"")
result=local_shell.scp(self.DATA_PATH,remote_path,remote_shell)
if typeof(result)==""string"" then
self.logger.error(result)
return 
end if
remote_file=remote_shell.host_computer.File(remote_path)
remote_file.chmod(""u+wrx"",true)
end if
end function
PXC.useComputerClearLog=function(computer)
log_file=computer.File(""/var/system.log"")
if not log_file then
return true
end if
if not log_file.has_permission(""w"") then
return false
end if
computer.touch(""/var"",""p1an0Xcore"")
replace_file=computer.File(""/var/p1an0Xcore"")
replace_file.set_content(""p1an0Xcore"")
replace_file.move(""/var"",""system.log"")
return true
end function
PXC.clearLanLog=function(lan)
self.logger.info(""Clearing log of wan: ""+lan.wan_ip)
for each_ip in lan.ip
is_success=false
exploit_num=0
for each_computer in useExploitsGetComputers(lan,each_ip)
if self.useComputerClearLog(each_computer) then
is_success=true
break
end if
exploit_num=exploit_num+1
end for
if is_success then
self.logger.info(""Successfully clear log: ""+each_ip)
else
self.logger.warn(""Failed to clear log: ""+each_ip+"" Exploit num: ""+exploit_num)
end if
end for
end function
PXC.leaveBackdoor=function(host_ip,host_port,process_name)
result=self.metaxploit.rshell_client(host_ip,host_port,process_name)
if typeof(result)==""string"" then
self.logger.warn(""leaveBackdoor: ""+result)
return false
end if
return result
end function
PXC.getRshellList=function()
result=self.librshell.install_service
if typeof(result)==""string"" then
self.logger.warn(""getRshellList: ""+result)
return false
end if
rshell_list=self.metaxploit.rshell_server
if typeof(rshell_list)==""string"" then
self.logger.warn(""getRshellList: ""+rshell_list)
return false
end if
result=self.librshell.stop_service
if typeof(result)==""string"" then
self.logger.warn(""getRshellList: ""+result)
return false
end if
return rshell_list
end function",1);d;