import_code("./lib/josn.src")

Parser = {}
Parser.source = ""
Parser._sourceLen = 0
Parser._p = 0		// index of next character to consume in source

Parser.init = function(source)
	self.source = source
	self._sourceLen = source.len
end function

Parser.parse = function(source=null)
	if source != null then self.init source
	self._p = 0
	return self._parseElement
end function

whitespace = " " + char(9) + char(10) + char(13)
Parser._skipWhitespace = function()
	while self._p < self._sourceLen
		c = self.source[self._p]
		if whitespace.indexOf(c) == null then break
		self._p = self._p + 1
	end while
end function
		
Parser._parseElement = function()
	return self._parseValue	// for now!
end function

Parser._parseValue = function()
	self._skipWhitespace
	c = self.source[self._p]
	if c == """" then return self._parseString
	if "0123456789-.".indexOf(c) != null then return self._parseNumber
	if c == "[" then return self._parseList
	if c == "{" then return self._parseMap
	if c == "t" and self.source[self._p:self._p+4] == "true" then
		self._p = self._p + 4
		return true
	end if
	if c == "f" and self.source[self._p:self._p+5] == "false" then
		self._p = self._p + 5
		return false
	end if
	if c == "n" and self.source[self._p:self._p+4] == "null" then
		self._p = self._p + 4
		return null
	end if
end function

Parser._parseList = function()
	self._p = self._p + 1		// skip "["
	self._skipWhitespace
	result = []
	while self._p < self._sourceLen
		c = self.source[self._p]
		if c == "]" then break
		result.push self._parseElement
		self._skipWhitespace
		// after an element, we should have either a comma or a ']'
		c = self.source[self._p]
		if c == "," then
			self._p = self._p + 1
			self._skipWhitespace
		end if
	end while
	self._p = self._p + 1
	return result
end function

Parser._parseMap = function()
	self._p = self._p + 1		// skip "{"
	self._skipWhitespace
	result = {}
	while self._p < self._sourceLen
		// grab the key (must be a string)
		c = self.source[self._p]
		if c == "}" then break
		if c != """" then
			print "JSON error: object member key must be a string literal"	// ToDo: better error handling!
			print "Error at position " + self._p + ": " + self.source[self._p-60 : self._p+60]
			return null
		end if
		key = self._parseString
		self._skipWhitespace
		
		// next token must be a colon
		if self.source[self._p] != ":" then
			print "JSON error: colon expected"
			print "Error at position " + self._p + ": " + self.source[self._p-60 : self._p+60]
			return null
		end if
		self._p = self._p + 1
		self._skipWhitespace
		
		// grab the value (could be anything)
		value = self._parseElement
		result[key] = value
		self._skipWhitespace
		
		// after a a key/value pair, we should have either a comma or a '}'
		c = self.source[self._p]
		if c == "," then
			self._p = self._p + 1
			self._skipWhitespace
		end if
	end while
	self._p = self._p + 1
	return result
end function

// Get a string literal from the source.  Advance to the next
// character after the closing quote.
Parser._parseString = function()
	self._p = self._p + 1
	startPos = self._p
	anyEscape = false
	while self._p < self._sourceLen
		c = self.source[self._p]
		self._p = self._p + 1
		if c == """" then break
		if c == "\" then
			anyEscape = true
			self._p = self._p + 1
		end if
	end while
	result = self.source[startPos : self._p-1]
	if anyEscape then result = unescape(result)
	return result
end function

// Get a numeric literal from the source.  Advance to the next
// character after the number.
Parser._parseNumber = function()
	startPos = self._p
	while self._p < self._sourceLen
		c = self.source[self._p]
		// Note that we are rather permissive here, consuming things like
		// 1-2e5+4E7, which is not valid JSON.  But we're not trying to be
		// a JSON validator; we're just trying to grok valid JSON as quickly
		// as we can.
		if "0123456789+-.eE".indexOf(c) == null then break
		self._p = self._p + 1
	end while
	result = val(self.source[startPos : self._p])
	return result
end function

// Generating JSON

_listToJSON = function(lst, compact, indent)
	ws = (_eol + "  "*(indent+1)) * (not compact)
	parts = ["[", ws]
	first = true
	for item in lst
		if not first then
			parts.push ","
			parts.push ws
		end if
		parts.push toJSON(item, compact, indent+1)
		first = false
	end for
	if not compact then parts.push _eol + "  " * indent
	parts.push "]"
	return join(parts, "")
end function

_mapToJSON = function(lst, compact, indent)
	ws = (_eol + "  "*(indent+1)) * (not compact)
	parts = ["{", ws]
	first = true
	for kv in lst
		if not first then
			parts.push ","
			parts.push ws
		end if
		parts.push toJSON(str(kv.key))
		parts.push ":"
		if not compact then parts.push " "
		parts.push toJSON(@kv.value, compact, indent+1)
		first = false
	end for
	if not compact then parts.push _eol + "  " * indent
	parts.push "}"
	return join(parts, "")
end function

// General utility data structures

_eol = char(13)
_hexDigitMap = {}
for i in range(0,15)
	if i < 10 then
		_hexDigitMap[str(i)] = i
	else
		_hexDigitMap[char(55+i)] = i	// (lowercase hex digit)
		_hexDigitMap[char(87+i)] = i	// (uppercase hex digit)
	end if
end for

_escapeFrom = ["\\", """", char(8), char(9), char(10), char(12), char(13)]
_escapeTo = ["\\\\", "\""", "\b","\t","\n","\f","\r"]
_escapeIndexes = _escapeFrom.indexes

query = "SELECT * FROM Websites WHERE country='U K';"

Lexer = {}
Lexer.tokenize = function(expression)
   result = [] // [{"type": type, "value": value}, ...]
   while expression
      for each_rule in self.rules
         type = each_rule["type"]
         ignore = each_rule["ignore"]
         value = null

         for each_regex in each_rule["regex"]
            regex_result = expression.matches(each_regex)
            for each in regex_result.indexes
               value = regex_result[each]
               break
            end for
            if value then break
         end for

         if value then
            expression = expression[value.len:]
            if ignore then break
            result.push({"type": type, "value": value})
            break
         end if
      end for
   end while
   return result
end function
Lexer.addRule = function(type, regex, ignore=false)
   self["rules"].push({"type": type, "regex": regex, "ignore": ignore})
end function
Lexer.init = function
   result = new Lexer
   result["rules"] = [] // [{"type": type, "regex": [regex, ...], "ignore": bool}, ..]
   return result
end function

lexer = Lexer.init
lexer.addRule("whitespace", ["^(\s+)"], true)
lexer.addRule("reserved", ["^(SELECT|WHERE|UPDATE|FROM|SET|DELETE)\b", "^(select|where|update|from|set|delete)\b"])
lexer.addRule("number", ["^([0-9]+(\.[0-9]+)?|0x[0-9a-fA-F]+|0b[01]+)\b"])
lexer.addRule("word", ["^([a-zA-Z0-9_]+)", "^(\$\{[a-zA-Z0-9_]+\})"])
lexer.addRule("string", ["^((?="")(?:""[^""\\]*(?:\\[\s\S][^""\\]*)*""))", "^((?=')(?:'[^'\\]*(?:\\[\s\S][^'\\]*)*'))", "^((?=`)(?:`[^`\\]*(?:\\[\s\S][^`\\]*)*`))"])
lexer.addRule("special", ["^(\(|\))", "^(!=|<>|==|<=|>=|!<|!>|\|\||::|->>|->|~~\*|~~|!~~\*|!~~|~\*|!~\*|!~|.)"])

Parser = {}
Parser.init = function
    result = new Parser
    return result
end function

tokens = globals.lexer.tokenize(query)
idx = 0
idx_stack = []
ast = {}

requireValue = function(value, result_type="requireValue")
    items = []
    globals.idx_stack.push(globals.idx)
    print "value: " + value + ": " + globals.idx
    if typeof(value) != "list" then
        value = [value]
    end if
    for each_value in value
        if globals.idx >= tokens.len or tokens[globals.idx]["value"] != each_value then
            globals.idx = globals.idx_stack.pop
            return {"flag": false, "type": result_type}
        end if
        items.push({"token_value": tokens[globals.idx]["value"], "token_type": tokens[globals.idx]["type"]})
        globals.idx = globals.idx + 1
    end for
    globals.idx_stack.pop
    return {"flag": true, "type": result_type, "items": items}
end function
requireType = function(types, result_type="requireType")
    items = []
    globals.idx_stack.push(globals.idx)
    print "type: " + types + ": " + globals.idx
    if typeof(types) == "string" then
        types = [types]
    end if
    for each_type in types
        if globals.idx >= tokens.len or tokens[globals.idx]["type"] != each_type then
            globals.idx = globals.idx_stack.pop
            return {"flag": false, "type": result_type}
        end if
        items.push({"token_value": tokens[globals.idx]["value"], "token_type": tokens[globals.idx]["type"]})
        globals.idx = globals.idx + 1
    end for
    globals.idx_stack.pop
    return {"flag": true, "type": result_type, "items": items}
end function
requireFunc = function(funcs, result_type="requireFunc")
    items = []
    globals.idx_stack.push(globals.idx)
    for each_func in funcs
        func_result = each_func()
        if func_result.flag == false then
            globals.idx = globals.idx_stack.pop
            return {"flag": false, "type": result_type}
        end if
        items.push(func_result)
    end for
    globals.idx_stack.pop
    return {"flag": true, "type": result_type, "items": items}
end function
epsilonFunc =  function(result_type="epsilonFunc")
    return {"flag": true, "type": result_type}
end function
parallel = function(funcs, result_type="parallel")
    globals.idx_stack.push(globals.idx)
    for each_func in funcs
        func_result = each_func()
        if func_result.flag == false then
            globals.idx = globals.idx_stack[-1]
        else
            globals.idx_stack.pop
            func_result.type = result_type
            return func_result
        end if
    end for
    globals.idx_stack.pop
    return {"flag": false, "type": result_type}
end function
optional = function(func, result_type="optional")
    return parallel([@func, @epsilonFunc], result_type)
end function
repeated = function(func, result_type="repeated")
    items = []
    flag = true
    while flag
        result = func()
        flag = result.flag
        items.push(result)
    end while
    return {"flag": true, "type": result_type, "items": items}
end function

requireTypeWord = function
    return requireType("word")
end function
requireTypeNumber = function
    return requireType("number")
end function
requireTypeString = function
    return requireType("string")
end function
requireValueStar = function
    return requireValue("*")
end function
requireValueSemicolon = function
    return requireValue(";")
end function
requireComma = function
    return requireValue(",")
end function
// production
selectStatement = function()
    tmp_func = function
        return requireValue("SELECT")
    end function
    return requireFunc([@tmp_func, @selectElements, @fromClause, @requireValueSemicolon], "selectStatement")
end function
selectElements = function()
    tmp_func1 = function
        return requireFunc([@requireComma, @selectElement])
    end function
    tmp_func2 = function
        return repeated(@tmp_func1)
    end function
    return requireFunc([@selectElement, @tmp_func2], "selectElements")
end function
selectElement = function()
    return parallel([@requireTypeWord, @requireValueStar], "selectElement")
end function
fromClause = function()
    tmp_func1 = function
        return requireValue("FROM") 
    end function
    tmp_func2 = function
        where_func = function
            return requireValue("WHERE")
        end function
        return requireFunc([@where_func, @expression])
    end function
    tmp_func3 = function
        return optional(@tmp_func2)
    end function
    return requireFunc([@tmp_func1, @tableSources, @tmp_func3], "fromClause")
end function
tableSources = function()
    tmp_func1 = function
        return requireFunc([@requireComma, @tableSource])
    end function
    tmp_func2 = function
        return repeated(@tmp_func1)
    end function
    return requireFunc([@tableSource, @tmp_func2], "tableSources")
end function
tableSource = function()
    return parallel([@requireTypeWord, @requireValueStar], "tableSource")
end function
expression = function()
    // tmp_func1 = function
    //     return notOperator() and expression()
    // end function
    // tmp_func2 = function
    //     return expression() and logicalOperator() and expression()
    // end function
    tmp_func3 = function
        parallel_func = function
            return parallel([@requireTypeWord, @requireTypeNumber, @requireTypeString], "predicate")
        end function
        return requireFunc([@requireTypeWord, @comparisonOperator, @parallel_func], "binaryComparisonPredic")
    end function
    // tmp_func4 = function
    //     return expressionAtom()
    // end function
    return parallel([@tmp_func3], "expression")
end function
expressionAtom= function
    return parallel([@requireTypeWord, @requireTypeNumber], "expressionAtom")
end function
notOperator = function()
    tmp_func1 = function
        return requireValue("NOT")
    end function
    tmp_func2 = function
        return requireValue("!")
    end function
    return parallel([@tmp_func2, @tmp_func2], "notOperator")
end function
logicalOperator = function()
    tmp_func1 = function
        return requireValue("AND")
    end function
    tmp_func2 = function
        return requireValue(["&", "&"])
    end function
    tmp_func3 = function
        return requireValue("XOR")
    end function
    tmp_func4 = function
        return requireValue("OR")
    end function
    tmp_func5 = function
        return requireValue("["|", "|"]")
    end function
    tmp_list = [@tmp_func1, @tmp_func2, @tmp_func3, @tmp_func4, @tmp_func5]
    return parallel(tmp_list, "logicalOperator")
end function
comparisonOperator = function()
    tmp_func1 = function
        return requireValue("=")
    end function
    tmp_func2 = function
        return requireValue(">")
    end function
    tmp_func3 = function
        return requireValue("<")
    end function
    tmp_func4 = function
        return requireValue(["<", "="])
    end function
    tmp_func5 = function
        return requireValue([">", "="])
    end function  
    tmp_func6 = function
        return requireValue(["<", ">"])
    end function
    tmp_func7 = function
        return requireValue(["<", "=", ">"])
    end function
    tmp_func8 = function
        return requireValue(["!", "="])
    end function
    tmp_list = [@tmp_func1, @tmp_func2, @tmp_func3, @tmp_func4, @tmp_func5, @tmp_func6, @tmp_func7, @tmp_func8]
    return parallel(tmp_list, "comparisonOperator")
end function

while true
    globals.query = user_input("SQL expression: ")
    globals.tokens = globals.lexer.tokenize(query)
    globals.idx = 0
    globals.idx_stack = []
    print globals.tokens
    resutl = selectStatement
    if resutl.flag and globals.idx == globals.tokens.len then
        print "SUCCESS!"
        print toJSON(resutl)
    end if
end while