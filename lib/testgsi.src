import_code("/home/p1an0/lib/json.src")
LexicalAnalyzer = {}
LexicalAnalyzer.tokenize = function(expression)
   result = [] // [{"type": type, "value": value, "loc": [line, colume]}, ...]
   line = 0
   colume = 0
   while expression
      for each_rule in self.rules
         type = each_rule["type"]
         ignore = each_rule["ignore"]
         value = null

         for each_regex in each_rule["regex"]
            regex_result = expression.matches(each_regex)
            for each in regex_result.indexes
               value = regex_result[each]
               break
            end for
            if value then break
         end for

         if value then
            colume = colume + value.len
            if type == "ENTER" then
               line = line + 1
               colume = 0
            end if
            expression = expression[value.len:]
            if ignore then break
            result.push({"type": type, "value": value, "loc": [line, colume]})
            break
         end if
      end for
   end while
   return result
end function
LexicalAnalyzer.addRule = function(type, regex, ignore=false)
    if typeof(regex) != "list" then
        regex = [regex]
    end if
    self["rules"].push({"type": type, "regex": regex, "ignore": ignore})
end function
LexicalAnalyzer.init = function
   result = new LexicalAnalyzer
   result["rules"] = [] // [{"type": type, "regex": [regex, ...], "ignore": bool}, ..]
   return result
end function

lexer = LexicalAnalyzer.init
lexer.addRule("SPACE", "^[ \t]+", true)
lexer.addRule("ENTER", "^[\r\n]", true)
lexer.addRule("COMMENT", "^\/\/.*(?=\n|\r|$)", true)
lexer.addRule("EQUALS", "^==")
lexer.addRule("NOT_EQ", "^!=")
lexer.addRule("GT_EQ", "^>=")
lexer.addRule("LT_EQ", "^<=")
lexer.addRule("ASSIGN", "^=")
lexer.addRule("LESS_THAN", "^<")
lexer.addRule("GREATER_THAN", "^>")
lexer.addRule("COLON", "^:")
lexer.addRule("ADD", "^\+")
lexer.addRule("MINUS", "^-")
lexer.addRule("DIV", "^\/")
lexer.addRule("MOD", "^%")
lexer.addRule("STAR", "^\*")
lexer.addRule("COMMA", "^,");
lexer.addRule("SEMI_COLON", "^;")
lexer.addRule("DOT", "^\.")
lexer.addRule("AT", "^@")
lexer.addRule("OPEN_PAREN", "^\(")
lexer.addRule("CLOSE_PAREN", "^\)")
lexer.addRule("OPEN_BRACE", "^\{")
lexer.addRule("CLOSE_BRACE", "^\}")
lexer.addRule("OPEN_BRACKET", "^\[")
lexer.addRule("CLOSE_BRACKET", "^\]")
lexer.addRule("IDENTIFIER", "^[A-Za-z_][A-Za-z0-9_]*")
lexer.addRule("STRING", "^((?="")(?:""[^""\\]*(?:\\[\s\S][^""\\]*)*""))")
lexer.addRule("NUMBER", "^-?\d+(\.\d+)?")


test = "
a = [1, 2, 3]
"

tokens = lexer.tokenize(test)
print tokens

GSItoken_idx = 0
GSIidx_stack = []
GSInode_stack = []
GSIast_stack = []
GIStokens = []
GSIparse = function(gsi_tokens)
    globals.GSItoken_idx = 0
    globals.GSIidx_stack = []
    globals.GSInode_stack = []
    globals.GSIast_stack = []
    globals.GIStokens = gsi_tokens
    globals.GSInode_stack.push(program)

    while globals.GSInode_stack.len > 0 and globals.GSItoken_idx < globals.GIStokens.len
        nodes = globals.GSInode_stack[-1]
        // print globals.GSItoken_idx
        if nodes == null or nodes.len <= 0 then
            globals.GSInode_stack.pop
            if globals.GSIast_stack.len >= 2 then
                last_ast = globals.GSIast_stack.pop
                current_ast = globals.GSIast_stack[-1]
                if last_ast.type == current_ast.type then
                    current_ast.items = current_ast.items + last_ast.items
                else
                    current_ast.items.push(last_ast)
                end if
                // print globals.GSInode_stack
                current_ast["range"] = {"start": current_ast.items[0]["range"]["start"], "end": current_ast.items[-1]["range"]["end"]}
            end if
            continue
        end if

        globals.GSIidx_stack.push(globals.GSItoken_idx)

        pass_flag = false
        while nodes.len > 0
            each_node = nodes.pull
            func_result = each_node.func()
            next_node = each_node.next_node
            print each_node
            print func_result
            print "END"
            if typeof(func_result) == "list" then
                for each_nn in func_result
                    each_nn.next_node = next_node
                end for
                globals.GSInode_stack.push(func_result)
                globals.GSIast_stack.push({"type": each_node.type, "items": []})
            else if func_result.flag == true then
                print func_result.items
                globals.GSInode_stack.push(next_node)
                globals.GSIast_stack.push({"type": each_node.type, "items": [func_result], "range": func_result["range"]})
                globals.GSIidx_stack.pop
                pass_flag = true
                break
            end if
        end while
        
        if pass_flag == false then
            globals.GSItoken_idx = globals.GSIidx_stack.pop
        end if
    end while
    if globals.GSItoken_idx == globals.GIStokens.len then
        print "YES!"
        while globals.GSIast_stack.len >= 2
            last_ast = globals.GSIast_stack.pop
            current_ast = globals.GSIast_stack[-1]
            if last_ast.type == current_ast.type then
                current_ast.items = current_ast.items + last_ast.items
            else
                current_ast.items.push(last_ast)
            end if
            current_ast["range"] = {"start": current_ast.items[0]["range"]["start"], "end": current_ast.items[-1]["range"]["end"]}
        end while
        print toJSON(globals.GSIast_stack[0])
        // print toJSON(globals.GSIast_stack[0])
    end if
end function
// start basic function
requireType = function(types, result_type="requireType")
    items = []
    if typeof(types) == "string" then
        types = [types]
    end if
    for each_type in types
        if globals.GSItoken_idx >= globals.GIStokens.len or globals.GIStokens[globals.GSItoken_idx]["type"] != each_type then
            return {"flag": false, "type": result_type}
        end if
        items.push({"token_value": globals.GIStokens[globals.GSItoken_idx]["value"], "token_type": globals.GIStokens[globals.GSItoken_idx]["type"], "loc": globals.GIStokens[globals.GSItoken_idx]["loc"]})
        globals.GSItoken_idx = globals.GSItoken_idx + 1
    end for
    ranges = {"start": [items[0]["loc"][0], items[0]["loc"][1]-items[0]["token_value"].len], "end": items[-1]["loc"]}
    return {"flag": true, "type": result_type, "items": items, "range": ranges}
end function
requireValue = function(value, result_type="requireValue")
    items = []
    if typeof(value) == "string" then
        value = [value]
    end if
    for each_value in value
        if globals.GSItoken_idx >= globals.GIStokens.len or globals.GIStokens[globals.GSItoken_idx]["value"] != each_value then
            return {"flag": false, "type": result_type}
        end if
        items.push({"token_value": globals.GIStokens[globals.GSItoken_idx]["value"], "token_type": globals.GIStokens[globals.GSItoken_idx]["type"], "loc": globals.GIStokens[globals.GSItoken_idx]["loc"]})
        globals.GSItoken_idx = globals.GSItoken_idx + 1
    end for
    ranges = {"start": [items[0]["loc"][0], items[0]["loc"][1]-items[0]["token_value"].len], "end": items[-1]["loc"]}
    return {"flag": true, "type": result_type, "items": items, "range": ranges}
end function
series = function(funcs, parent_node, result_type="series")
    nodes = []
    nodes.push({"func": @funcs[-1], "next_node": parent_node.next_node, "type": result_type})
    for i in range(funcs.len-2, 0, -1)
        nodes.push({"func": @funcs[i], "next_node": [nodes[-1]], "type": result_type})
    end for
    return [nodes[-1]]
end function
parallel = function(funcs, parent_node, result_type="parallel")
    nodes = []
    for each_func in funcs
        nodes.push({"func": @each_func, "next_node": parent_node.next_node, "type": result_type})
    end for
    return nodes
end function
any = function(func, parent_node, result_type="any")
    node = {"func": @func, "next_node": null, "type": result_type}
    node.next_node = [node, parent_node.next_node]
    return [node]
end function
epsilonFunc =  function(result_type="epsilonFunc")
    return {"flag": true, "type": result_type, "items": null, "range": null}
end function
optional = function(func, parent_node, result_type="optional")
    return parallel([@func, @epsilonFunc], parent_node, result_type)
end function
// end basic function
program = function()
    tmp_func1 = function()
        return 
    end function
    return parallel([@variableDeclaration], null, "program")
end function
requireComma = function()
   return requireType("COMMA", "requireComma")
end function
requireColon = function()
   return requireType("COLON", "requireColon")
end function
requireIdentifier = function()
   return requireType("IDENTIFIER", "requireIdentifire")
end function
requireAssign = function()
   return requireType("ASSIGN", "requireAssign")
end function
requireString = function()
   return requireType("STRING", "requireString")
end function
requireNumber = function()
   return requireType("NUMBER", "requireNumber")
end function
requireOpenParen = function()
   return requireType("OPEN_PAREN", "requireOpenParen")
end function
requireCloseParen = function()
   return requireType("CLOSE_PAREN", "requireCloseParen")
end function

requireNull = function()
   return requireValue("null", "requireNull")
end function
requireEnd = function()
   return requireValue("end", "requireEnd")
end function
requireThen = function()
   return requireValue("then", "requireThen")
end function
requireIf = function()
   return requireValue("if", "requireIf")
end function
requireEndIf = function()
   return requireValue(["end", "if"], "requireEndIf")
end function
// math operator start
requireStar = function()
   return requireType("STAR", "requireStar")
end function
requireDiv = function()
   return requireType("DIV", "requireDiv")
end function
requireMod = function()
   return requireType("MOD", "requireMod")
end function
requireAdd = function()
   return requireType("ADD", "requireAdd")
end function
requireMinus = function()
   return requireType("MINUS", "requireMinus")
end function
// math operator end
// logical operator start
requireEquals = function()
   return requireType("EQUALS", "requireEquals")
end function
requireNoteq = function()
   return requireType("NOT_EQ", "requireNoteq")
end function
requireGteq = function()
   return requireType("GT_EQ", "requireGteq")
end function
requireLteq = function()
   return requireType("LT_EQ", "requireLteq")
end function
requireGt = function()
   requireType("GREATER_THAN", "requireGt")
end function
requireLt = function()
   requireType("LESS_THAN", "requireLt")
end function
requireNot = function()
   return requireValue("not", "requireNot")
end function
requireAnd = function()
   return requireValue("and", "requireAnd")
end function
requireOr = function()
   return requireValue("or", "requireOr")
end function
// logical operator end
// eval expression start
pri1EvalExpression = function()
   return series([@requireOpenParen, @objectExpression, @requireCloseParen])
end function
pri2EvalExpression = function()
   return series([@requireNot, @objectExpression])
end function
pri3Operator = function()
   return parallel([@requireStar, @requireDiv, @requireMod])
end function
pri3EvalExpression = function()
   return series([@objectExpression, @pri3Operator, @objectExpression])
end function
pri4Operator = function()
   return parallel([@requireAdd, @requireMinus])
end function
pri4EvalExpression = function()
   return series([@objectExpression, @pri4Operator, @objectExpression])
end function
pri5Operator = function()
   return parallel([@requireGteq, @requireLteq, @requireGt, @requireLt])
end function
pri5EvalExpression = function()
   return series([@objectExpression, @pri5Operator, @objectExpression])
end function
pri6Operator = function()
   return parallel([@requireEquals, @requireNoteq])
end function
pri6EvalExpression = function()
   return series([@objectExpression, @pri6Operator, @objectExpression])
end function
pri7EvalExpression = function()
   return series([@objectExpression, @requireAnd, @objectExpression])
end function
pri8EvalExpression = function()
   return series([@objectExpression, @requireOr, @objectExpression])
end function
evalExpression = function()
   return parallel([@pri1EvalExpression, @pri2EvalExpression, @pri3EvalExpression, @pri4EvalExpression, @pri5EvalExpression, @pri6EvalExpression, @pri7EvalExpression, @pri8EvalExpression], "evalExpression")
end function
// eval expression end
objectExpression = function
   return parallel([@requireNull, @requireIdentifier, @requireString, @requireNumber, @listExpression], "objectExpression")
end function
// list expression start
requireOpenBracket = function()
   return requireType("OPEN_BRACKET", "requireOpenBracket")
end function
requireCloseBracket = function()
   return requireType("CLOSE_BRACKET", "requireCloseBracket")
end function
listElements = function()
   tmp_func1 = function
      return series([@requireComma, @objectExpression], "listElements")
   end function
   tmp_func2 = function
      return any(@tmp_func1, "listElements")
   end function
   return series([@objectExpression, @tmp_func2], "listElements")
end function
listExpression = function()
   return series([@requireOpenBracket, @listElements, @requireCloseBracket], "listExpression")
end function
// list expression end
// map expression start
requireOpenBrace = function()
   return requireType("OPEN_BRACE", "requireOpenBrace")
end function
requireCloseBrace = function()
   return requireType("CLOSE_BRACE", "requireCloseBrace")
end function
pairExpression = function()
   return series([@objectExpression, @requireColon, @objectExpression], "pairExpression")
end function
mapElements = function()
   tmp_func1 = function
      return series([@requireComma, @pairExpression])
   end function
   tmp_func2 = function
      return any(@tmp_func1)
   end function
   return series([@pairExpression, @tmp_func2], "mapElements")
end function
mapExpression = function()
   return series([@requireOpenBrace, @mapElements, @requireCloseBrace], "mapExpression")
end function
// map expression end
// if statement start
ifStatement =  function()
   return series([@requireIf, @objectExpression, @requireThen, @blockStatement], "ifStatement")
end function
// if statement end
newExpression = function()
   return parallel([@requireIdentifier, @requireAssign, @objectExpression], "newExpression")
   return 
end function
variableDeclaration = function(parent_node)
   return series([@requireIdentifier, @requireAssign, @objectExpression], "variableDeclaration") 
end function
GSIparse(tokens)