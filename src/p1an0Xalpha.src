// environment variable begin
ENV_VAR = {}
// environment variable end
// global variables begin
SHELL = get_shell
WORK_DIR = current_path
USER_NAME = function
    return globals.UTILS.getUser(globals.SHELL)
end function
HOST_NAME = function
    return globals.SHELL.host_computer.get_name
end function
HOME_DIR = function
    if globals.USER_NAME == "root" then
        return "/root"
    else
        return "/home/" + globals.USER_NAME
    end if
end function
USED_SHELL = []
METAX_PATH = "/lib/metaxploit.so"
METAX_LIB = include_lib(METAX_PATH)
if not METAX_LIB then
    METAX_PATH = current_path + "/metaxploit.so"
    METAX_LIB = include_lib(METAX_PATH)
end if
// global variables end
// cache begin
SCAN_CACHE = {}
// SCAN_CACHE = {
//     public_ip: {
//         local_ip: {
//             "port": {port_num: net_session, ...},
//             "lib": [metaLib, ...],
//             "shell" : [shell, ...],
//             "computer": [commputer, ...],
//             "file": [file, ...],
//             "user": {username: passwd, ...},
//             "mail": {account: passwd, ...},
//             "bank": {account: passwd, ...}
//         },
//         ...
//     },
//     ...
// }
SCAN_CACHE.hasMachine = function(pub_ip, loc_ip)
    return globals.SCAN_CACHE.hasIndex(pub_ip) and globals.SCAN_CACHE[pub_ip].hasIndex(loc_ip)
end function
SCAN_CACHE.syncMachine = function(pub_ip, loc_ip)
    if not globals.SCAN_CACHE.hasIndex(pub_ip) then
        globals.SCAN_CACHE[pub_ip] = {}
    end if
    globals.SCAN_CACHE[pub_ip][loc_ip] = {"port": {}, "lib": [], "shell": [], "computer": [], "file": [], "user": {}, "mail": {}, "bank": {}}
end function
SCAN_CACHE.syncSession = function(pub_ip, loc_ip, port_num, net_session)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    globals.SCAN_CACHE[pub_ip][loc_ip]["port"][port_num] = net_session
end function
SCAN_CACHE.syncLib = function(pub_ip, loc_ip, meta_lib)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    globals.SCAN_CACHE[pub_ip][loc_ip]["lib"].push(meta_lib)
end function
SCAN_CACHE.syncItem = function(pub_ip, loc_ip, item)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    if typeof(item) == "shell" then
        globals.SCAN_CACHE[pub_ip][loc_ip]["shell"].push(item)
    else if typeof(item) == "computer" then
        globals.SCAN_CACHE[pub_ip][loc_ip]["computer"].push(item)
    else if typeof(item) == "file" then
        globals.SCAN_CACHE[pub_ip][loc_ip]["file"].push(item)
    end if
end function
SCAN_CACHE.getSession = function(pub_ip, loc_ip)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    return globals.SCAN_CACHE[pub_ip][loc_ip]["port"].values
end function
SCAN_CACHE.getMetaLib = function(pub_ip, loc_ip)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    return globals.SCAN_CACHE[pub_ip][loc_ip]["lib"]
end function
SCAN_CACHE.getShell = function(pub_ip, loc_ip)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    return globals.SCAN_CACHE[pub_ip][loc_ip]["shell"]
end function
SCAN_CACHE.getComputer = function(pub_ip, loc_ip)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    return globals.SCAN_CACHE[pub_ip][loc_ip]["computer"]
end function
SCAN_CACHE.getFile = function(pub_ip, loc_ip)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    return globals.SCAN_CACHE[pub_ip][loc_ip]["file"]
end function
METAX_CACHE = {}
// METAX_CACHE = {
//     name: {
//         version: {
//             address: zone,
//             ...
//         },
//         ...
//     },
//     ...
// }
METAX_CACHE.hasLib = function(libName, libVersion)
    return globals.METAX_CACHE.hasIndex(libName) and globals.METAX_CACHE[libName].hasIndex(libVersion)
end function
METAX_CACHE.syncVulner = function(libName, libVersion, address, zone)
    if not globals.METAX_CACHE.hasIndex(libName) then
        globals.METAX_CACHE[libName] = {}
    end if
    if not globals.METAX_CACHE[libName].hasIndex(libVersion) then
        globals.METAX_CACHE[libName][libVersion] = {}
    end if
    globals.METAX_CACHE[libName][libVersion][address] = zone
end function
METAX_CACHE.getVulner = function(libName, libVersion)
    if not globals.METAX_CACHE.hasLib(libName, libVersion) then
        return {}
    else
        return globals.METAX_CACHE[libName][libVersion]
    end if
end function
// cache end
// color begin
COLOR = {}
COLOR.FILE = "<color=#6F6FEE>"
COLOR.HIDEN_FILE = "<color=#9479B3>"
COLOR.ROOT_PREV = "<color=#D15858>"
COLOR.USER_PREV = "<color=#6F6FEE>"
COLOR.GUEST_PREV = "<color=#C6C8BC>"
COLOR.SHELL_PATH = "<color=white>"
COLOR.SHELL_BAR = "<color=#3590C5>"
COLOR.SHELL_INPUT = "<color=#9CD3D9>"
COLOR.SHELL_USER = function
    perm = globals.UTILS.getPermission(globals.SHELL)
    if perm == "root" then
        return globals.COLOR.ROOT_PREV
    else if perm == "user" then
        return globals.COLOR.USER_PREV
    else
        return globals.COLOR.GUEST_PREV
    end if
end function
COLOR.COMMAND_OUTPUT = "<color=white>"
// color end
// utils begin
UTILS = {}
UTILS.getFile = function(item, file_path, is_folder_flag=false)
    if typeof(item) == "shell" then
        result_file = item.host_computer.File(file_path)
        if not result_file then
            return "No such file or directory"
        else if not is_folder(result_file) and is_folder_flag == true then
            return "Not a directory" 
        else if is_folder(result_file) and is_folder_flag == false then
            return "Is a directory"
        else
            return result_file
        end if 
    else if typeof(item) == "computer" then
        result_file = item.File(file_path)
        if not result_file then
            return "No such file or directory"
        else if not is_folder(result_file) and is_folder_flag == true then
            return "Not a directory" 
        else if is_folder(result_file) and is_folder_flag == false then
            return "Is a directory"
        else
            return result_file
        end if 
    else if typeof(item) == "file" then
        item_parent = item.parent
        while item_parent
            item = item_parent
            item_parent = item.parent
        end while
        path_split = file_path.split("/")[1:]
        for each_split in path_split[:-1]
            for each_folder in item.get_folders
                if each_folder.name == each_split then
                    item = each_folder
                    break
                end if
            end for
        end for
        if is_folder_flag == true then
            for each_folder in item.get_folders
                if each_folder.name == path_split[-1] then
                    item = each_folder
                    break
                end if
            end for
        else if is_folder_flag == false then
            for each_file in item.get_files
                if each_file.name == path_split[-1] then
                    item = each_file
                    break
                end if
            end for
        else
            for each_folder in item.get_folders
                if each_folder.name == path_split[-1] then
                    item = each_folder
                    break
                end if
            end for
            for each_file in item.get_files
                if each_file.name == path_split[-1] then
                    item = each_file
                    break
                end if
            end for
        end if
        if not item or item.path != file_path then
            return "No such file or directory"
        else if not item.has_permission("r") then
            return "Permission denied"
        else if not is_folder(item) and is_folder_flag == true then
            return "Not a directory" 
        else if is_folder(item) and is_folder_flag == false then
            return "Is a directory"
        else
            return item
        end if
    else
        return "Requrie shell, computer, or file"
    end if
end function
UTILS.getPermission = function(item)
    passwd_file = null
    if typeof(item) == "shell" then
        passwd_file = item.host_computer.File("/etc/passwd")
    else if typeof(item) == "computer" then
        passwd_file = item.File("/etc/passwd")
    else if typeof(item) == "file" then
        passwd_file = globals.UTILS.getFile(item, "/etc/passwd")
    end if

    if typeof(passwd_file) == "file" then
        if passwd_file.has_permission("w") then
            return "root"
        else if not passwd_file.has_permission("r") then
            return "guest"
        else
            return "user"
        end if
    else
        return null
    end if
end function
UTILS.writeFile = function(item, file_path, file_name, content)
    file = globals.UTILS.getFile(item, file_path + "/" + file_name)
    if typeof(file) == "string" then
        if file == "No such file or directory" then
            file = "Failed to create file"
            if typeof(item) == "shell" then
                file = item.host_computer.touch(file_path, file_name)
            else if typeof(item) == "computer" then
                file = item.touch(file_path, file_name)
            end if
            if typeof(file) == "string" then
                return file
            else
                file = globals.UTILS.getFile(item, file_path + "/" + file_name)
                if typeof(file) == "string" then
                    return file
                end if
                result = file.set_content(content)
                if result != true then
                    return result
                end if
            end if
        else
            return file
        end if
    else
        result = file.set_content(content)
        if result != true then
            return result
        end if
    end if
end function
UTILS.getUser = function(item)
    perm = globals.UTILS.getPermission(item)
    if perm == "root" then
        return "root"
    else if perm == "guest" then
        return "guest"
    else
        dir = globals.UTILS.getFile(item, "/home", true)
        if typeof(dir) == "string" then
            return null
        end if
        for each_folder in dir.get_folders
            if each_folder.has_permission("w") then
                return each_folder.name
            end if
        end for 
    end if
end function
UTILS.resolvePath = function(relative_path)
    result_path = null
    if relative_path == null or relative_path.len <= 0 then
        result_path = globals.WORK_DIR
    else if relative_path[0] == "/" then
        result_path = relative_path
    else if relative_path[0] == "~" and (relative_path.len <= 1 or relative_path[1] == "/") then
        result_path = globals.HOME_DIR + relative_path[1:]
    else if globals.WORK_DIR == "/" then
        result_path = globals.WORK_DIR + relative_path
    else
        result_path = globals.WORK_DIR + "/" + relative_path
    end if

    path_split = result_path.split("/")[1:]
    index = 0
    while index < path_split.len
        if path_split[index] == "." or path_split[index] == "" then
            path_split.remove(index)
            index = index - 1
        else if path_split[index] == ".." then
            if index - 1 >= 0 then
                path_split.remove(index - 1)
                path_split.remove(index - 1)
                index = index - 2
            else
                path_split.remove(index)
                index = index - 1
            end if
        end if
        index = index + 1
    end while

    result_path = ""
    for each_split in path_split
        result_path = result_path + "/" + each_split
    end for
    if result_path.len == 0 then
        result_path = "/"
    end if
    return result_path
end function
UTILS.useShell = function(target_shell)
    globals.USED_SHELL.push([globals.SHELL, globals.WORK_DIR])
    globals.SHELL = target_shell
    globals.WORK_DIR = globals.HOME_DIR
end function
UTILS.exitShell = function()
    used_shell = globals.USED_SHELL.pop
    globals.SHELL = used_shell[0]
    globals.WORK_DIR = used_shell[1]
end function
UTILS.isHost = function()
    return globals.USED_SHELL.len == 0
end function
UTILS.cliPrint = function(message)
    print(globals.COLOR.COMMAND_OUTPUT+message+"</color>")
end function
UTILS.cliInput = function(message, is_pass=false)
    return user_input(globals.COLOR.COMMAND_OUTPUT+message, is_pass)
end function
// utils end
// lexcial analyzer begin
LexicalAnalyzer = {}
LexicalAnalyzer.tokenize = function(expression)
   result = [] // [{"type": type, "value": value, "loc": [line, colume]}, ...]
   line = 0
   colume = 0
   while expression
      for each_rule in self.rules
         type = each_rule["type"]
         ignore = each_rule["ignore"]
         value = null

         for each_regex in each_rule["regex"]
            regex_result = expression.matches(each_regex)
            for each in regex_result.indexes
               value = regex_result[each]
               break
            end for
            if value then break
         end for

         if value then
            colume = colume + value.len
            if type == "ENTER" then
               line = line + 1
               colume = 0
            end if
            expression = expression[value.len:]
            if ignore then break
            result.push({"type": type, "value": value, "loc": [line, colume]})
            break
         end if
      end for
   end while
   return result
end function
LexicalAnalyzer.addRule = function(type, regex, ignore=false)
    if typeof(regex) != "list" then
        regex = [regex]
    end if
    self["rules"].push({"type": type, "regex": regex, "ignore": ignore})
end function
LexicalAnalyzer.init = function
   result = new LexicalAnalyzer
   result["rules"] = [] // [{"type": type, "regex": [regex, ...], "ignore": bool}, ..]
   result.addRule("SPACE", "^[ \t]+", true)
   result.addRule("ENTER", "^[\r\n]", true)
   return result
end function
// lexical analyzer end
// cli parser begin
CLIPARSER = {}
CLIPARSER.lexer = LexicalAnalyzer.init
CLIPARSER.lexer.addRule("STRING", "^((?="")(?:""[^""\\]*(?:\\[\s\S][^""\\]*)*""))")
CLIPARSER.lexer.addRule("OTHER", "^[^\s]*")
CLIPARSER.parse = function(input)
    tokens = globals.CLIPARSER.lexer.tokenize(input)
    result = []
    for each_token in tokens
        if each_token.type == "STRING" then
            result.push(each_token["value"][1:-1])
        else
            result.push(each_token["value"])
        end if
    end for
    return result
end function
// cli parser end
// argument parser begin
ArgParser = {"value": null, "flag": null, "opt_value": null}
// arg is optional if defualt != null
// parse arguments in add order
ArgParser.addValue = function(id, desc, default=null) // eg: [local ip] [public ip]
    if default != null then
        self.opt_value.push([id, desc, default])
    else
        self.value.push([id, desc])
    end if
end function
ArgParser.addFlag = function(id, desc) // eg: -t -txz
    self.flag.push([id, desc])
end function
ArgParser.desc = function
    result = ""
    for each_value in self.value
        result = result + "[" + each_value[1] + "] "
    end for
    for each_value in self.opt_value
        result = result + "[opt: " + each_value[1] + ", default: " + each_value[2] + "] "
    end for
    for each_flag in self.flag
        result = result + "[" + each_flag[0] + ": " + each_flag[1] + "] "
    end for
    return result
end function
ArgParser.parse = function(args)
    index = 0
    result = {}
    for each_value in self.value
        if index >= args.len then
            return "Require argument: [" + each_value[1] + "]"
        end if
        if args[index][0] == "-" then
            return "Require argument: [" + each_value[1] + "]. Get flag: " + args[index] + " instead"
        end if
        id = each_value[0]
        if args[index][0] == "$" then
            if globals.ENV_VAR.hasIndex(args[index][1:]) then
                result[id] = globals.ENV_VAR[args[index][1:]]
            else
                result[id] = ""
            end if
        else
            result[id] = args[index]
        end if
        index = index + 1
    end for
    for each_value in self.opt_value
        id = each_value[0]
        if index >= args.len or args[index][0] == "-" then
            result[id] = each_value[2]
            continue
        end if
        if args[index][0] == "$" then
            if globals.ENV_VAR.hasIndex(args[index][1:]) then
                result[id] = globals.ENV_VAR[args[index][1:]]
            else
                result[id] = ""
            end if
        else
            result[id] = args[index]
        end if
        index = index + 1
    end for
    arg_flags = []
    while index < args.len
        if args[index][0] != "-" then
            return "Unknown argument: " + args[index]
        end if
        for each_flag in args[index][1:]
            arg_flags.push(each_flag)
        end for
        index = index + 1
    end while
    for each_flag in self.flag
        id = each_flag[0]
        if arg_flags.indexOf(id[1:]) != null then
            result[id] = true
        else
            result[id] = false
        end if
    end for
    return result
end function
ArgParser.init = function
    result = new ArgParser
    result.value = []
    result.flag = []
    result.opt_value = []
    return result
end function
// argument parser end 
// commmands begin
// system commands begin
COMMANDS = {}
COMMANDS.regCmd = function(cmd, desc="")
    globals.COMMANDS[cmd] = {}
    globals.COMMANDS[cmd]["desc"] = desc
    globals.COMMANDS[cmd]["parser"] = ArgParser.init
end function
COMMANDS.regCmd("help")
COMMANDS["help"].parser.addValue("cmd", "command name", "ALL_COMMAND")
COMMANDS["help"].execute = function(args)
    args = globals.COMMANDS["help"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    if args["cmd"] == "ALL_COMMAND" then
        for each_cmd in globals.COMMANDS.indexes
            if typeof(globals.COMMANDS[each_cmd]) == "map" then
                globals.UTILS.cliPrint(each_cmd)
            end if
        end for
        return
    end if
    if globals.COMMANDS.hasIndex(args["cmd"]) == null then
        return "Command '" + args["cmd"] + "' not found"
    else
        globals.UTILS.cliPrint(globals.COMMANDS[args["cmd"]].desc)
        globals.UTILS.cliPrint("Usage: " + args["cmd"] + " " + globals.COMMANDS[args["cmd"]]["parser"].desc)
    end if
end function
COMMANDS.regCmd("ls")
COMMANDS["ls"].parser.addValue("dir_path", "dir path", ".")
COMMANDS["ls"].parser.addFlag("-l", "Show file details")
COMMANDS["ls"].parser.addFlag("-a", "Show hiden file")
COMMANDS["ls"].execute = function(args)
    args = globals.COMMANDS["ls"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    dir_path = globals.UTILS.resolvePath(args["dir_path"])
    dir = globals.UTILS.getFile(globals.SHELL, dir_path, true)
    if typeof(dir) == "string" then
        return dir
    end if

    sub_files = dir.get_folders + dir.get_files
    output = ""
    for each_sub_file in sub_files
        file_name = each_sub_file.name
        permission = each_sub_file.permissions
        file_owner = each_sub_file.owner
        file_size = each_sub_file.size
        file_group = each_sub_file.group

        if args["-a"] or not file_name[0] == "." then
            if not file_name[0] == "."then
                file_name = globals.COLOR.COMMAND_OUTPUT+each_sub_file.name+"</color>"
            else
                file_name = globals.COLOR.HIDEN_FILE+each_sub_file.name+"</color>"
            end if
            if is_folder(each_sub_file) then file_name = globals.COLOR.FILE+each_sub_file.name+"</color>"

            if output.len > 0 then 
                output = output + "\n"
            end if
            if args["-l"] then
                output = output + globals.COLOR.COMMAND_OUTPUT+ permission + " " + file_owner + " " + file_group + " " + file_size + " 00:00 </color>" + file_name
            else
                output = output + file_name
            end if
        end if
    end for
    
    globals.UTILS.cliPrint(format_columns(output))
end function
COMMANDS.regCmd("cd")
COMMANDS["cd"].parser.addValue("dir_path", "dir path", ".")
COMMANDS["cd"].execute = function(args)
    args = globals.COMMANDS["cd"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    dir_path = globals.UTILS.resolvePath(args["dir_path"])
    dir = globals.UTILS.getFile(globals.SHELL, dir_path, true)
    if typeof(dir) == "string" then
        return dir
    end if

    globals.WORK_DIR = dir.path
end function
COMMANDS.regCmd("cat")
COMMANDS["cat"].parser.addValue("file_path", "file path")
COMMANDS["cat"].execute = function(args)
    args = globals.COMMANDS["cat"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    file_path = globals.UTILS.resolvePath(args["file_path"])
    file = globals.UTILS.getFile(globals.SHELL, file_path)
    if typeof(file) == "string" then
        return file
    end if

    globals.UTILS.cliPrint(file.get_content)
end function
COMMANDS.regCmd("whoami")
COMMANDS["whoami"].execute = function(args)
    globals.UTILS.cliPrint(globals.USER_NAME)
end function
COMMANDS.regCmd("rm")
COMMANDS["rm"].parser.addValue("file_path", "file path")
COMMANDS["rm"].parser.addFlag("-r", "remove directory")
COMMANDS["rm"].execute = function(args)
    args = globals.COMMANDS["rm"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    file_path = globals.UTILS.resolvePath(args["file_path"])
    file = globals.UTILS.getFile(globals.SHELL, file_path, args["-r"])
    if typeof(file) == "string" then
        return file
    end if

    if not file.has_permission("w") then 
        globals.UTILS.cliPrint("Permission denied: " + file.path)
        return
    end if
    file.delete
end function
COMMANDS.regCmd("clear", "clear terminal output")
COMMANDS["clear"].execute = function(args)
    clear_screen
end function
COMMANDS.regCmd("chmod")
COMMANDS["chmod"].parser.addValue("mode", "u,g,o+wrx")
COMMANDS["chmod"].parser.addValue("file_path", "file path")
COMMANDS["chmod"].parser.addFlag("-r", "is recursive")
COMMANDS["chmod"].execute = function(args)
    args = globals.COMMANDS["chmod"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    file_path = globals.UTILS.resolvePath(args["file_path"])
    file = globals.UTILS.getFile(globals.SHELL, file_path, null)
    if typeof(file) == "string" then
        return file
    end if

    result = file.chmod(args["mode"], args["-r"])
    if typeof(result) == "string" then
        globals.UTILS.cliPrint(result)
    else
        return "Permission denied"
    end if
end function
COMMANDS.regCmd("su", "switch user")
COMMANDS["su"].parser.addValue("user", "user name")
COMMANDS["su"].execute = function(args)
    args = globals.COMMANDS["su"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    
    if args["user"] ==  globals.USER_NAME then
        return "You are already " + globals.USER_NAME
    end if

    passwd = globals.UTILS.cliInput("Password: ", true)
    target_shell = get_shell(args["user"], passwd)
    if not target_shell then 
        return "Authentication failure"
    end if
    
    globals.UTILS.useShell(target_shell)
end function
COMMANDS.regCmd("exit", "back to previous shell")
COMMANDS["exit"].execute = function(args)
    if globals.USED_SHELL.len < 1 then
        confirm = globals.UTILS.cliInput("Are you sure you want to exit p1an0Xalpha?[yes/no]: ")
        if confirm == "yes" then exit
        return
    end if
    globals.UTILS.exitShell()
end function
COMMANDS.regCmd("env", "show all environment variables")
COMMANDS["env"].execute = function(args)
    for each_var in globals.ENV_VAR.indexes
        globals.UTILS.cliPrint(each_var + "=" + globals.ENV_VAR[each_var])
    end for
end function
COMMANDS.regCmd("export", "add environment variable")
COMMANDS["export"].parser.addValue("var", "variable")
COMMANDS["export"].parser.addValue("value", "value")
COMMANDS["export"].execute = function(args)
    args = globals.COMMANDS["export"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    globals.ENV_VAR[args["var"]] = args["value"]
end function
COMMANDS.regCmd("unset", "remove environment variable")
COMMANDS["unset"].parser.addValue("var", "variable")
COMMANDS["unset"].execute = function(args)
    args = globals.COMMANDS["unset"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    if globals.ENV_VAR.hasIndex(args["var"]) then
        globals.ENV_VAR.remove(args["var"])
    end if
end function
COMMANDS.regCmd("echo")
COMMANDS["echo"].parser.addValue("value", "value")
COMMANDS["echo"].execute = function(args)
    args = globals.COMMANDS["echo"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    globals.UTILS.cliPrint(args["value"])
end function
COMMANDS.regCmd("ifconfig")
COMMANDS["ifconfig"].execute = function(args)
    computer = globals.SHELL.host_computer
    devices = computer.network_devices
    devices_split = devices.split(char(10))[:-1]
    for item in devices_split
        item_split = item.split(" ")
        flag = ""
        if item_split[2] then
            flag = "MONITOR"
        end if
        globals.UTILS.cliPrint(item_split[0] + ": flags=<" + flag + ">")
        globals.UTILS.cliPrint("  inet " + computer.local_ip + "  gateway" + computer.network_gateway)
        globals.UTILS.cliPrint("  inet " + computer.public_ip)
        globals.UTILS.cliPrint("  chipset " + item_split[1])
    end for
    
end function
// system commands end
// hack commands begin
COMMANDS.regCmd("jump", "jump to host computer of current shell")
COMMANDS["jump"].parser.addValue("ip", "router ip", "")
COMMANDS["jump"].parser.addValue("jump_path", "jump path", "/home/guest")
COMMANDS["jump"].execute = function(args)
    args = globals.COMMANDS["jump"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    file_name = floor(rnd * 100 + 1)
    jump_src = "
    custom_object = get_custom_object
    metax = include_lib(params[0])
    custom_object.shell = get_shell
    custom_object.meta_libs = []
    lib_dir = get_shell.host_computer.File(""/lib"")
    for each_lib in lib_dir.get_files
        custom_object.meta_libs.push(metax.load(each_lib.path))
    end for

    router = get_router()
    if params[1].len > 0 then
        router = get_router(params[1])
    end if
    if router == null then
        custom_object.router = null
        exit
    end if
    custom_object.router = router
    custom_object.net_sessions = {}
    for ip in router.devices_lan_ip
        custom_object.net_sessions[ip] = {}
        ports = router.device_ports(ip)
        if typeof(ports) == ""list"" then
            for port in ports
                port_num = port.port_number
                net_session = metax.net_use(ip, port_num)
                if not net_session then
                    continue
                end if
                if port.get_lan_ip == ip then
                    custom_object.net_sessions[ip][port_num] = net_session
                else
                    if not custom_object.net_sessions.hasIndex(port.get_lan_ip) then
                        custom_object.net_sessions[port.get_lan_ip] = {}
                    end if
                    custom_object.net_sessions[port.get_lan_ip][port_num] = net_session
                end if
            end for
        end if
    end for
    custom_object.net_sessions[router.local_ip][0] = metax.net_use(router.local_ip, 0)
    " 
    jump_path = globals.UTILS.resolvePath(args["jump_path"])
    result = globals.UTILS.writeFile(globals.SHELL, jump_path, file_name + ".src", jump_src)
    if typeof(result) == "string" then
        return result
    end if

    scp(get_shell, globals.METAX_PATH, jump_path, globals.SHELL)
    rnd_time = rnd
    wait(rnd_time)
    src_result = globals.UTILS.getFile(globals.SHELL, jump_path + "/" + file_name + ".src")
    if typeof(src_result) == "string" or src_result.get_content != jump_src then
        return "Invalid jumpfile"
    end if
    result = globals.SHELL.build(jump_path + "/" + file_name + ".src", jump_path)
    if result.len > 0 then
        return result
    end if
    result = globals.SHELL.launch(jump_path + "/" + file_name, globals.METAX_PATH + " " + args["ip"])
    if result != true then
        return "Failed to jump"
    end if
    bin_result = globals.UTILS.getFile(globals.SHELL, jump_path + "/" + file_name)
    if typeof(bin_result) == "string" then
        return bin_result
    end if
    src_del = src_result.delete
    if src_del.len > 0 then
        return src_del
    end if
    bin_del = bin_result.delete
    if bin_del.len > 0 then
        return bin_del
    end if
end function
COMMANDS.regCmd("scan", "scan target router and cache result")
COMMANDS["scan"].parser.addValue("ip", "router ip", "")
COMMANDS["scan"].execute = function(args)
    args = globals.COMMANDS["scan"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    if args["ip"].len > 0 and not is_valid_ip(args["ip"]) then
        return "Invalid ip"
    end if

    target_ip = null
    if globals.UTILS.isHost then
        result = {}
        router = get_router()
        if args["ip"].len > 0 then
            router = get_router(args["ip"])
        end if
        if not router then
            return "Failed to connect to router"
        end if
        target_ip = router.public_ip
        globals.UTILS.cliPrint("router:")
        globals.UTILS.cliPrint("  public ip: " + router.public_ip)
        globals.UTILS.cliPrint("  local  ip: " + router.local_ip)
        for ip in router.devices_lan_ip
            globals.SCAN_CACHE.syncMachine(router.public_ip, ip)
            ports = router.device_ports(ip)
            if typeof(ports) == "list" then
                for port in ports
                    port_num = port.port_number
                    net_session = globals.METAX_LIB.net_use(ip, port_num)
                    if not net_session then
                        continue
                    end if
                    if port.get_lan_ip == ip then
                        globals.SCAN_CACHE.syncSession(router.public_ip, ip, port_num, net_session)
                    else
                        globals.SCAN_CACHE.syncSession(router.public_ip, port.get_lan_ip, port_num, net_session)
                    end if
                end for
            end if
        end for
        globals.SCAN_CACHE[router.public_ip][router.local_ip]["port"][0] = globals.METAX_LIB.net_use(router.local_ip, 0)
    else
        result = globals.COMMANDS.jump.execute([args["ip"]])
        if typeof(result) then
            return result
        end if
        if get_custom_object.router == null then
            return "Failed to connect to router"
        end if
        pub_ip = get_custom_object.router.public_ip
        loc_ip = get_custom_object.router.local_ip
        target_ip = pub_ip
        globals.UTILS.cliPrint("router:")
        globals.UTILS.cliPrint("  public ip: " + pub_ip)
        globals.UTILS.cliPrint("  local  ip: " + loc_ip)
        for ip in get_custom_object.net_sessions.indexes
            globals.SCAN_CACHE.syncMachine(pub_ip, ip)
            for port_num in get_custom_object.net_sessions[ip].indexes
                net_session = get_custom_object.net_sessions[ip][port_num]
                globals.SCAN_CACHE.syncSession(pub_ip, ip, port_num, net_session)
            end for
        end for
        for meta_lib in get_custom_object.meta_libs
            globals.SCAN_CACHE.syncLib(pub_ip, get_custom_object.shell.host_computer.local_ip, meta_lib)
        end for
    end if
    globals.UTILS.cliPrint("devices:")
    for ip in globals.SCAN_CACHE[target_ip].indexes
        globals.UTILS.cliPrint("  " + ip + ": ")
        for port in globals.SCAN_CACHE[target_ip][ip]["port"]
            globals.UTILS.cliPrint("    " + port["key"] + " " + port["value"].dump_lib.lib_name + " " + port["value"].dump_lib.version)
        end for
    end for
end function
COMMANDS.regCmd("hack", "exploit net_session or meta_lib")
COMMANDS["hack"].parser.addValue("local_ip", "local ip")
COMMANDS["hack"].parser.addValue("public_ip", "public ip", "")
COMMANDS["hack"].execute = function(args)
    args = globals.COMMANDS["hack"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    
    pub_ip = args["public_ip"]
    if pub_ip.len == 0 then
        pub_ip = globals.SHELL.host_computer.public_ip
    end if
    loc_ip = args["local_ip"]
    if not is_valid_ip(pub_ip) or is_lan_ip(pub_ip) then
        return "Invalid public ip"
    end if
    if not is_lan_ip(loc_ip) then
        return "Invalid local ip"
    end if
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        return "Scan cache not found"
    end if

    meta_libs = globals.SCAN_CACHE.getMetaLib(pub_ip, loc_ip) + globals.SCAN_CACHE.getSession(pub_ip, loc_ip)
    if meta_libs.len == 0 then
        return "No open port or local lib"
    end if
    for lib in meta_libs
        if typeof(lib) == "NetSession" then
            lib = lib.dump_lib
        end if
        libName = lib.lib_name
        libVersion = lib.version
        globals.UTILS.cliPrint(libName + " " + libVersion)

        if not globals.METAX_CACHE.hasLib(libName, libVersion) then
            for address in globals.METAX_LIB.scan(lib)
                info = globals.METAX_LIB.scan_address(lib, address).split("Unsafe check: ").replace(char(10), "")
                for info_line in info
                    if info_line == info[0] then continue
                    zone = info_line[info_line.indexOf("<b>")+3:info_line.indexOf("</b>")]
                    globals.METAX_CACHE.syncVulner(libName, libVersion, address, zone)
                end for
            end for
        end if

        for each_vulner in globals.METAX_CACHE.getVulner(libName, libVersion)
            address = each_vulner["key"]
            zone = each_vulner["value"]
            flow = lib.overflow(address, zone)
            if typeof(flow) != "shell" and typeof(flow) != "computer" and typeof(flow) != "file" then
                flow = lib.overflow(address, zone, loc_ip)
            end if
            print typeof(flow)
            globals.SCAN_CACHE.syncItem(pub_ip, loc_ip, flow)
        end for
    end for

    globals.UTILS.cliPrint("shell: ")
    shells = globals.SCAN_CACHE.getShell(pub_ip, loc_ip)
    for shell in shells
        user = globals.UTILS.getUser(shell)
        globals.UTILS.cliPrint("  " + user)
    end for
    globals.UTILS.cliPrint("computer: ")
    computers = globals.SCAN_CACHE.getComputer(pub_ip, loc_ip)
    for computer in computers
        user = globals.UTILS.getUser(computer)
        globals.UTILS.cliPrint("  " + user)
    end for
    globals.UTILS.cliPrint("file: ")
    files = globals.SCAN_CACHE.getFile(pub_ip, loc_ip)
    for file in shells
        user = globals.UTILS.getUser(file)
        globals.UTILS.cliPrint("  " + user)
    end for
    
end function
COMMANDS.regCmd("shell", "display cached shell")
// hack commands end
// commands end
// main loop begin
getInput = function()
    suffix = "$"
    show_path = globals.WORK_DIR[:len(globals.HOME_DIR)].replace(globals.HOME_DIR, "~") + globals.WORK_DIR[len(globals.HOME_DIR):]
    if globals.USER_NAME == "root" then
        suffix = "#"
        show_path = globals.WORK_DIR
    end if
    output = char(10)+globals.COLOR.SHELL_BAR+"<pos=05>———(</color><b>"+globals.COLOR.SHELL_USER+globals.USER_NAME+"@"+globals.HOST_NAME+"</color></b>"+globals.COLOR.SHELL_BAR+")—[</color><b>"+globals.COLOR.SHELL_PATH+show_path+"</b>"+globals.COLOR.SHELL_BAR+"]<voffset=-0.5em>"+"<pos=00>|<voffset=-1em><space=-0.6em>|<voffset=-1.5em><pos=05>——<b></color>"+globals.COLOR.SHELL_USER+suffix+"</color></b>"+globals.COLOR.SHELL_INPUT+" "
    return user_input(output)
end function
executeCommand = function(command, arguments)
    if not globals.COMMANDS.hasIndex(command) then
        return "Command '"+command+"' not found"
    end if
    return globals.COMMANDS[command].execute(arguments)
end function
while true
    input = getInput
    if not input then continue

    parsed_input = globals.CLIPARSER.parse(input)
    execute_result = executeCommand(parsed_input[0], parsed_input[1:])
    if typeof(execute_result) == "string" then
        globals.UTILS.cliPrint(execute_result)
    end if
end while
// main loop end
Exploit = {}
Exploit.init = function
    
end function
Device = {"ports": [], "shell": [], "computer": [], "file": [], }
Device.init = function
    
end function