// environment variable begin
ENV_VAR = {}
ENV_VAR.JUMP_PATH = "/home/guest"
ENV_VAR.JUMP_NAME = "jumpfile"
ENV_VAR.TRACELESS  = "true"
// environment variable end
// global variables begin
SHELL = get_shell
WORK_DIR = current_path
USER_NAME = function
    return globals.UTILS.getUser(globals.SHELL)
end function
HOST_NAME = function
    return globals.SHELL.host_computer.get_name
end function
HOME_DIR = function
    if globals.USER_NAME == "root" then
        return "/root"
    else
        return "/home/" + globals.USER_NAME
    end if
end function
USED_SHELL = []
METAX_PATH = "/lib/metaxploit.so"
METAX_LIB = include_lib(METAX_PATH)
if not METAX_LIB then
    METAX_PATH = current_path + "/metaxploit.so"
    METAX_LIB = include_lib(METAX_PATH)
end if
CRYPTO_LIB = include_lib("/lib/crypto.so")
if not CRYPTO_LIB then
    CRYPTO_LIB = include_lib(current_path + "/crypto.so")
end if
// global variables end
// cache begin
SCAN_CACHE = {}
// SCAN_CACHE = {
//     public_ip: {
//         local_ip: {
//             "port": {port_num: net_session, ...},
//             "lib": [metaLib, ...],
//             "children": [child_ip, ...],
//             "shell" : [shell, ...],
//             "computer": [commputer, ...],
//             "file": [file, ...],
//             "user": {username: passwd, ...},
//             "mail": {account: passwd, ...},
//             "bank": {account: passwd, ...}
//         },
//         ...
//     },
//     ...
// }
SCAN_CACHE.hasMachine = function(pub_ip, loc_ip)
    return globals.SCAN_CACHE.hasIndex(pub_ip) and globals.SCAN_CACHE[pub_ip].hasIndex(loc_ip)
end function
SCAN_CACHE.syncMachine = function(pub_ip, loc_ip)
    if not globals.SCAN_CACHE.hasIndex(pub_ip) then
        globals.SCAN_CACHE[pub_ip] = {}
    end if
    globals.SCAN_CACHE[pub_ip][loc_ip] = {"port": {}, "lib": [], "children": [], "shell": [], "computer": [], "file": [], "user": {}, "mail": {}, "bank": {}}
end function
SCAN_CACHE.syncSession = function(pub_ip, loc_ip, port_num, net_session)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    globals.SCAN_CACHE[pub_ip][loc_ip]["port"][port_num] = net_session
end function
SCAN_CACHE.syncChild = function(pub_ip, loc_ip, child_ip)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    if globals.SCAN_CACHE[pub_ip][loc_ip]["children"].indexOf(child_ip) == null then
        globals.SCAN_CACHE[pub_ip][loc_ip]["children"].push(child_ip)
    end if
end function
SCAN_CACHE.syncLib = function(pub_ip, loc_ip, meta_lib)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    globals.SCAN_CACHE[pub_ip][loc_ip]["lib"].push(meta_lib)
end function
SCAN_CACHE.syncItem = function(pub_ip, loc_ip, item)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    if typeof(item) == "shell" then
        globals.SCAN_CACHE[pub_ip][loc_ip]["shell"].push(item)
    else if typeof(item) == "computer" then
        globals.SCAN_CACHE[pub_ip][loc_ip]["computer"].push(item)
    else if typeof(item) == "file" then
        globals.SCAN_CACHE[pub_ip][loc_ip]["file"].push(item)
    end if
end function
SCAN_CACHE.getRouters = function(pub_ip, loc_ip)
    if globals.SCAN_CACHE.hasIndex(pub_ip) then
        result = []
        walk = function(ip, routers)
            if ip == outer.loc_ip then
                outer.result = routers
                return
            end if
            if globals.SCAN_CACHE[pub_ip].hasIndex(ip) then
                for next_ip in globals.SCAN_CACHE[pub_ip][ip]["children"]
                    walk(next_ip, routers + [ip])
                end for
            end if
        end function
        walk(get_router(pub_ip).local_ip, [])
        return result
    else
        return []
    end if
end function
SCAN_CACHE.getMasterKey = function(pub_ip)
    if not globals.SCAN_CACHE.hasIndex(pub_ip) then
        return null
    end if
    count = {}
    for ip in globals.SCAN_CACHE[pub_ip].indexes
        for user in globals.SCAN_CACHE[pub_ip][ip]["user"]
            if not count.hasIndex(user["key"]) then
                count[user["key"]] = {"count": 0, "passwd": user["value"]}
            end if
            count[user["key"]]["count"] = count[user["key"]]["count"] + 1
        end for
    end for
    max_count = -1
    max_passwd = null
    for user in count.indexes
        if count[user]["count"] > max_count then
            max_count = count[user]["count"]
            max_passwd = count[user]["passwd"]
        end if
    end for
    return max_passwd
end function
SCAN_CACHE.getUser = function(pub_ip, loc_ip)
    if globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        return globals.SCAN_CACHE[pub_ip][loc_ip]["user"]
    else
        return {}
    end if
end function
SCAN_CACHE.getShell = function(pub_ip, loc_ip)
    if globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        return globals.SCAN_CACHE[pub_ip][loc_ip]["shell"]
    else
        return []
    end if
end function
SCAN_CACHE.grabUser = function(pub_ip, loc_ip)
    if globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        items = globals.SCAN_CACHE[pub_ip][loc_ip]["shell"] + globals.SCAN_CACHE[pub_ip][loc_ip]["computer"] + globals.SCAN_CACHE[pub_ip][loc_ip]["file"]
        for item in items
            file = globals.UTILS.getFile(item, "/etc/passwd")
            if typeof(file) == "file" and file.get_content != null then
                file_split = file.get_content.split("\n")
                for user in file_split
                    if user.len == 0 then
                        continue
                    end if
                    user_split = user.split(":")
                    globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user_split[0]] = user_split[1]
                end for
                break
            end if
        end for
    end if
end function
SCAN_CACHE.grabMail = function(pub_ip, loc_ip)
    if globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        items = globals.SCAN_CACHE[pub_ip][loc_ip]["shell"] + globals.SCAN_CACHE[pub_ip][loc_ip]["computer"] + globals.SCAN_CACHE[pub_ip][loc_ip]["file"]
        for item in items
            user = globals.UTILS.getUser(item)
            if user == "root" then
                home = globals.UTILS.getFile(item, "/home", true)
                if typeof(home) == "file" then
                    for user_dir in home.get_folders
                        if user_dir.name != "guest" then
                            file = globals.UTILS.getFile(item, "/home/"+user_dir.name+"/Config/Mail.txt")
                            if typeof(file) == "file" and file.get_content != null then
                                file_split = file.get_content.split("\n")
                                for mail in file_split
                                    if mail.len == 0 then
                                        continue
                                    end if
                                    mail_split = mail.split(":")
                                    globals.SCAN_CACHE[pub_ip][loc_ip]["mail"][mail_split[0]] = mail_split[1]
                                end for
                            end if
                        end if
                    end for
                end if
                break
            else if user != "guest" then
                file = globals.UTILS.getFile(item, "/home/"+user+"/Config/Mail.txt")
                if typeof(file) == "file" and file.get_content != null then
                    file_split = file.get_content.split("\n")
                    for mail in file_split
                        if mail.len == 0 then
                            continue
                        end if
                        mail_split = mail.split(":")
                        globals.SCAN_CACHE[pub_ip][loc_ip]["mail"][mail_split[0]] = mail_split[1]
                    end for
                end if
            end if
        end for
    end if
end function
SCAN_CACHE.grabBank = function(pub_ip, loc_ip)
    if globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        items = globals.SCAN_CACHE[pub_ip][loc_ip]["shell"] + globals.SCAN_CACHE[pub_ip][loc_ip]["computer"] + globals.SCAN_CACHE[pub_ip][loc_ip]["file"]
        for item in items
            user = globals.UTILS.getUser(item)
            if user == "root" then
                home = globals.UTILS.getFile(item, "/home", true)
                if typeof(home) == "file" then
                    for user_dir in home.get_folders
                        if user_dir.name != "guest" then
                            file = globals.UTILS.getFile(item, "/home/"+user_dir.name+"/Config/Bank.txt")
                            if typeof(file) == "file" and file.get_content != null then
                                file_split = file.get_content.split("\n")
                                for bank in file_split
                                    if bank.len == 0 then
                                        continue
                                    end if
                                    bank_split = bank.split(":")
                                    globals.SCAN_CACHE[pub_ip][loc_ip]["bank"][bank_split[0]] = bank_split[1]
                                end for
                            end if
                        end if
                    end for
                end if
                break
            else if user != "guest" then
                file = globals.UTILS.getFile(item, "/home/"+user+"/Config/Bank.txt")
                if typeof(file) == "file" and file.get_content != null then
                    file_split = file.get_content.split("\n")
                    for bank in file_split
                        if bank.len == 0 then
                            continue
                        end if
                        bank_split = bank.split(":")
                        globals.SCAN_CACHE[pub_ip][loc_ip]["bank"][bank_split[0]] = bank_split[1]
                    end for
                end if
            end if
        end for
    end if
end function
METAX_CACHE = {}
// METAX_CACHE = {
//     name: {
//         version: {
//             address: zone,
//             ...
//         },
//         ...
//     },
//     ...
// }
METAX_CACHE.hasLib = function(libName, libVersion)
    return globals.METAX_CACHE.hasIndex(libName) and globals.METAX_CACHE[libName].hasIndex(libVersion)
end function
METAX_CACHE.syncVulner = function(libName, libVersion, address, zone)
    if not globals.METAX_CACHE.hasIndex(libName) then
        globals.METAX_CACHE[libName] = {}
    end if
    if not globals.METAX_CACHE[libName].hasIndex(libVersion) then
        globals.METAX_CACHE[libName][libVersion] = {}
    end if
    globals.METAX_CACHE[libName][libVersion][address] = zone
end function
METAX_CACHE.getVulner = function(libName, libVersion)
    if not globals.METAX_CACHE.hasLib(libName, libVersion) then
        return {}
    else
        return globals.METAX_CACHE[libName][libVersion]
    end if
end function
// cache end
// color begin
COLOR = {}
COLOR.FILE = "<color=#6F6FEE>"
COLOR.HIDEN_FILE = "<color=#9479B3>"
COLOR.ROOT_PREV = "<color=#D15858>"
COLOR.USER_PREV = "<color=#6F6FEE>"
COLOR.GUEST_PREV = "<color=#C6CF99>"
COLOR.SHELL_PATH = "<color=white>"
COLOR.SHELL_BAR = "<color=#3590C5>"
COLOR.SHELL_INPUT = "<color=#9CD3D9>"
COLOR.SHELL_USER = function
    perm = globals.UTILS.getPermission(globals.SHELL)
    if perm == "root" then
        return globals.COLOR.ROOT_PREV
    else if perm == "user" then
        return globals.COLOR.USER_PREV
    else
        return globals.COLOR.GUEST_PREV
    end if
end function
COLOR.COMMAND_OUTPUT = "<color=white>"
// color end
// utils begin
UTILS = {}
UTILS.getFile = function(item, file_path, is_folder_flag=false)
    if typeof(item) == "shell" then
        result_file = item.host_computer.File(file_path)
        if not result_file then
            return "No such file or directory"
        else if not is_folder(result_file) and is_folder_flag == true then
            return "Not a directory" 
        else if is_folder(result_file) and is_folder_flag == false then
            return "Is a directory"
        else
            return result_file
        end if 
    else if typeof(item) == "computer" then
        result_file = item.File(file_path)
        if not result_file then
            return "No such file or directory"
        else if not is_folder(result_file) and is_folder_flag == true then
            return "Not a directory" 
        else if is_folder(result_file) and is_folder_flag == false then
            return "Is a directory"
        else
            return result_file
        end if 
    else if typeof(item) == "file" then
        item_parent = item.parent
        while item_parent
            item = item_parent
            item_parent = item.parent
        end while
        path_split = file_path.split("/")[1:]
        for each_split in path_split[:-1]
            for each_folder in item.get_folders
                if each_folder.name == each_split then
                    item = each_folder
                    break
                end if
            end for
        end for
        if is_folder_flag == true then
            for each_folder in item.get_folders
                if each_folder.name == path_split[-1] then
                    item = each_folder
                    break
                end if
            end for
        else if is_folder_flag == false then
            for each_file in item.get_files
                if each_file.name == path_split[-1] then
                    item = each_file
                    break
                end if
            end for
        else
            for each_folder in item.get_folders
                if each_folder.name == path_split[-1] then
                    item = each_folder
                    break
                end if
            end for
            for each_file in item.get_files
                if each_file.name == path_split[-1] then
                    item = each_file
                    break
                end if
            end for
        end if
        if not item or item.path != file_path then
            return "No such file or directory"
        else if not item.has_permission("r") then
            return "Permission denied"
        else if not is_folder(item) and is_folder_flag == true then
            return "Not a directory" 
        else if is_folder(item) and is_folder_flag == false then
            return "Is a directory"
        else
            return item
        end if
    else
        return "Requrie shell, computer, or file"
    end if
end function
UTILS.getPermission = function(item)
    passwd_file = null
    if typeof(item) == "shell" then
        passwd_file = item.host_computer.File("/etc/passwd")
    else if typeof(item) == "computer" then
        passwd_file = item.File("/etc/passwd")
    else if typeof(item) == "file" then
        passwd_file = globals.UTILS.getFile(item, "/etc/passwd")
    end if

    if typeof(passwd_file) == "file" then
        if passwd_file.has_permission("w") then
            return "root"
        else if not passwd_file.has_permission("r") then
            return "guest"
        else
            return "user"
        end if
    else
        return null
    end if
end function
UTILS.writeFile = function(item, file_path, file_name, content)
    file = globals.UTILS.getFile(item, file_path + "/" + file_name)
    if typeof(file) == "string" then
        if file == "No such file or directory" then
            file = "Failed to create file"
            if typeof(item) == "shell" then
                file = item.host_computer.touch(file_path, file_name)
            else if typeof(item) == "computer" then
                file = item.touch(file_path, file_name)
            end if
            if typeof(file) == "string" then
                return file
            else
                file = globals.UTILS.getFile(item, file_path + "/" + file_name)
                if typeof(file) == "string" then
                    return file
                end if
                result = file.set_content(content)
                if result != true then
                    return result
                end if
            end if
        else
            return file
        end if
    else
        result = file.set_content(content)
        if result != true then
            return result
        end if
    end if
end function
UTILS.getUser = function(item)
    perm = globals.UTILS.getPermission(item)
    if perm == "root" then
        return "root"
    else if perm == "guest" then
        return "guest"
    else
        dir = globals.UTILS.getFile(item, "/home", true)
        if typeof(dir) == "string" then
            return null
        end if
        for each_folder in dir.get_folders
            if each_folder.has_permission("w") then
                return each_folder.name
            end if
        end for 
    end if
end function
UTILS.resolvePath = function(relative_path)
    result_path = null
    if relative_path == null or relative_path.len <= 0 then
        result_path = globals.WORK_DIR
    else if relative_path[0] == "/" then
        result_path = relative_path
    else if relative_path[0] == "~" and (relative_path.len <= 1 or relative_path[1] == "/") then
        result_path = globals.HOME_DIR + relative_path[1:]
    else if globals.WORK_DIR == "/" then
        result_path = globals.WORK_DIR + relative_path
    else
        result_path = globals.WORK_DIR + "/" + relative_path
    end if

    path_split = result_path.split("/")[1:]
    index = 0
    while index < path_split.len
        if path_split[index] == "." or path_split[index] == "" then
            path_split.remove(index)
            index = index - 1
        else if path_split[index] == ".." then
            if index - 1 >= 0 then
                path_split.remove(index - 1)
                path_split.remove(index - 1)
                index = index - 2
            else
                path_split.remove(index)
                index = index - 1
            end if
        end if
        index = index + 1
    end while

    result_path = ""
    for each_split in path_split
        result_path = result_path + "/" + each_split
    end for
    if result_path.len == 0 then
        result_path = "/"
    end if
    return result_path
end function
UTILS.useShell = function(target_shell)
    globals.USED_SHELL.push([globals.SHELL, globals.WORK_DIR])
    globals.SHELL = target_shell
    globals.WORK_DIR = globals.HOME_DIR
end function
UTILS.exitShell = function()
    used_shell = globals.USED_SHELL.pop
    globals.SHELL = used_shell[0]
    globals.WORK_DIR = used_shell[1]
end function
UTILS.isHost = function()
    return globals.SHELL.host_computer.public_ip == get_shell.host_computer.public_ip and globals.SHELL.host_computer.local_ip == get_shell.host_computer.local_ip
end function
UTILS.cliPrint = function(message)
    print(globals.COLOR.COMMAND_OUTPUT+message+"</color>")
end function
UTILS.cliInput = function(message, is_pass=false, any_key=false)
    return user_input(globals.COLOR.COMMAND_OUTPUT+message, is_pass, any_key)
end function
UTILS.makeJumpfile = function(shell, jump_path, file_name)
    jump_src = "
    metax = include_lib(current_path+""/metaxploit.so"")
    cmd = params[0]
    if cmd == ""su"" then
        username = params[1]
        passwd = params[2]
        shell = get_shell(username, passwd)
        get_custom_object[cmd] = shell
    else if cmd == ""scan"" then
        local_flag = true
        if params.len > 1 and params[1].len > 0 then
            local_flag = false
            root_router = get_router(params[1])
        else
            root_router = get_router(get_shell.host_computer.public_ip)
        end if
        if not root_router then
            get_custom_object[cmd] = null
            exit
        end if

        router_stack = [root_router]
        result = {}
        while router_stack.len > 0
            router = router_stack.pop
            if not result.hasIndex(router.local_ip) then
                result[router.local_ip] = {""port"": {}, ""children"": []}
            end if
            for ip in router.devices_lan_ip
                next_router = get_router(ip)
                if next_router and not result.hasIndex(ip) then
                    router_stack.push(next_router)
                end if
                if router.local_ip != ip and not result.hasIndex(ip) then
                    result[router.local_ip][""children""].push(ip)
                    result[ip] = {""port"": {}, ""children"": []}
                end if

                ports = router.device_ports(ip)
                if typeof(ports) == ""list"" then
                    for port in ports
                        port_num = port.port_number
                        if local_flag then
                            net_session = metax.net_use(ip, port_num)
                        else if router.local_ip == root_router.local_ip and router.local_ip == ip then
                            net_session = metax.net_use(root_router.public_ip, port_num)
                        else
                            continue
                        end if
                        if not net_session then
                            continue
                        end if
                        if port.get_lan_ip == ip then
                            result[ip][""port""][port_num] = net_session
                        else
                            if not result.hasIndex(port.get_lan_ip) then
                                result[ip][""children""].push(port.get_lan_ip)
                            end if
                            if not result.hasIndex(port.get_lan_ip) then
                                result[port.get_lan_ip] = {""port"": {}, ""children"": []}
                            end if
                            result[port.get_lan_ip][""port""][port_num] = net_session
                        end if
                    end for
                end if
            end for
            if local_flag then
                result[router.local_ip][""port""][0] = metax.net_use(router.local_ip, 0)
            else if router.local_ip == root_router.local_ip then
                result[router.local_ip][""port""][0] = metax.net_use(router.public_ip, 0)
            end if
        end while

        get_custom_object[cmd] = {""result"": result, ""router"": root_router}
    else if cmd == ""lib"" then
        lib_dir = get_shell.host_computer.File(""/lib"")
        if lib_dir then
            get_custom_object[cmd] = []
            for file in lib_dir.get_files
                lib = metax.load(file.path)
                if lib then
                    get_custom_object[cmd].push(lib)
                end if
            end for
        else
            get_custom_object[cmd] = null
        end if
    else if cmd == ""hack"" then
        items = []
        meta_libs = get_custom_object.meta_libs
        vulners = get_custom_object.vulners
        is_bounce = get_custom_object.is_bounce
        loc_ip = params[1]
        if params.len > 2 and params[2].len > 0 then
            pub_ip = params[2]
        else
            pub_ip = get_shell.host_computer.public_ip
        end if
        for index in meta_libs.indexes
            metaLib = meta_libs[index]
            bounce = is_bounce[index]
            libName = metaLib.lib_name
            libVersion = metaLib.version
            for vulner in vulners[libName][libVersion]
                address = vulner[""key""]
                zone = vulner[""value""]
                if bounce then
                    flow = metaLib.overflow(address, zone, loc_ip)
                else
                    flow = metaLib.overflow(address, zone)
                end if
                if typeof(flow) == ""shell"" then
                    if flow.host_computer.local_ip != loc_ip or flow.host_computer.public_ip != pub_ip then
                        print flow.host_computer.local_ip
                        continue
                    end if
                else if typeof(flow) == ""computer"" then
                    if flow.local_ip != loc_ip or flow.public_ip != pub_ip then
                        print flow.local_ip
                        continue
                    end if
                end if
                items.push(flow)
            end for
        end for
        get_custom_object[cmd] = items
    end if
    "
    write = globals.UTILS.writeFile(shell, jump_path, file_name + ".src", jump_src)
    if typeof(write) == "string" then
        return write
    end if
    compile = shell.build(jump_path + "/" + file_name + ".src", jump_path)
    if compile.len != 0 then
        return compile
    end if
end function
UTILS.useJumpfile = function(shell, jump_path, file_name, args, object=null) // unsafe custom.indexes
    args_string = ""
    for arg in args
        args_string = args_string + arg  + " "
    end for

    jumpfile_path = jump_path + "/" + file_name
    if args[0] == "lib" or args[0] == "scan" then
        metax = globals.UTILS.getFile(shell, jump_path + "/metaxploit.so")
        if typeof(metax) != "file" then
            upload = scp(get_shell, globals.METAX_PATH, jump_path, shell)
            if upload != true then
                return upload
            end if
        end if
    end if

    for index in get_custom_object.indexes
        get_custom_object.remove(@index)
    end for
    if object then
        for index in object.indexes
            get_custom_object[index] = object[index]
        end for
    end if
    run = shell.launch(jumpfile_path, args_string)
    if run != true then
        make = globals.UTILS.makeJumpfile(shell, jump_path, file_name)
        if typeof(make) == "string" then
            return make
        end if

        for index in get_custom_object.indexes
            get_custom_object.remove(@index)
        end for
        if object then
            for index in object.indexes
                get_custom_object[index] = object[index]
            end for
        end if
        run = shell.launch(jumpfile_path, args_string)
        if run != true then
            return "Failed to launch jumpfile"
        end if
    end if

    custom = get_custom_object
    cmd = args[0]
    if cmd == "su" and custom.hasIndex(cmd) then
        if typeof(@custom[cmd]) == "shell" or typeof(@custom[cmd]) == "null" then
            return custom[cmd]
        else
            return "Jumpfile error: su"
        end if
    else if cmd == "scan" and custom.hasIndex(cmd) then
        if typeof(@custom["scan"]) == "null" then
            return custom["scan"]
        end if
        if typeof(@custom["scan"]) == "map" and custom["scan"].hasIndex("router") and typeof(@custom["scan"]["router"]) == "router" then
            if custom["scan"].hasIndex("result") and typeof(@custom["scan"]["result"]) == "map" then
                for loc_ip in custom["scan"]["result"].indexes
                    if typeof(@loc_ip) == "string" and typeof(@custom["scan"]["result"][loc_ip]) == "map" then
                        if custom["scan"]["result"][loc_ip].hasIndex("port") and typeof(@custom["scan"]["result"][loc_ip]["port"]) == "map" then
                            for port_num in custom["scan"]["result"][loc_ip]["port"].indexes
                                if typeof(@port_num) != "number" or typeof(@custom["scan"]["result"][loc_ip]["port"][port_num]) != "NetSession" then
                                    return "Jumpfile error: net session"
                                end if
                            end for
                        else
                            return "Jumpfile error: port"
                        end if
                        if custom["scan"]["result"][loc_ip].hasIndex("children") and typeof(@custom["scan"]["result"][loc_ip]["children"]) == "list" then
                            for child in custom["scan"]["result"][loc_ip]["children"]
                                if typeof(@child) != "string" then
                                    return "Jumpfile error: child"
                                end if
                            end for
                        else
                            return "Jumpfile error: children"
                        end if
                    else
                        return "Jumpfile error: local ip"
                    end if
                end for
                return custom["scan"]
            else
                return "Jumpfile error: result"
            end if
        else
            return "Jumpfile error: scan"
        end if
    else if cmd == "lib" and custom.hasIndex(cmd) and typeof(@custom[cmd]) == "list" then
        for lib in custom[cmd]
            if typeof(@lib) != "MetaLib" then
                return "Jumpfile error: lib"
            end if
        end for
        return custom[cmd]
    else if cmd == "hack" and custom.hasIndex(cmd) and typeof(@custom[cmd]) == "list" then
        for item in custom[cmd]
            if typeof(@item) != "string" and typeof(@item) != "number" and typeof(@item) != "shell" and typeof(@item) != "computer" and typeof(@item) != "file" and typeof(@item) != "null"then
                return "Jumpfile error: hack"
            end if
        end for
        return custom[cmd]
    else
        return "Jumpfile error: cmd"
    end if
end function
// utils end
// lexcial analyzer begin
LexicalAnalyzer = {}
LexicalAnalyzer.tokenize = function(expression)
   result = [] // [{"type": type, "value": value, "loc": [line, colume]}, ...]
   line = 0
   colume = 0
   while expression
      for each_rule in self.rules
         type = each_rule["type"]
         ignore = each_rule["ignore"]
         value = null

         for each_regex in each_rule["regex"]
            regex_result = expression.matches(each_regex)
            for each in regex_result.indexes
               value = regex_result[each]
               break
            end for
            if value then break
         end for

         if value then
            colume = colume + value.len
            if type == "ENTER" then
               line = line + 1
               colume = 0
            end if
            expression = expression[value.len:]
            if ignore then break
            result.push({"type": type, "value": value, "loc": [line, colume]})
            break
         end if
      end for
   end while
   return result
end function
LexicalAnalyzer.addRule = function(type, regex, ignore=false)
    if typeof(regex) != "list" then
        regex = [regex]
    end if
    self["rules"].push({"type": type, "regex": regex, "ignore": ignore})
end function
LexicalAnalyzer.init = function
   result = new LexicalAnalyzer
   result["rules"] = [] // [{"type": type, "regex": [regex, ...], "ignore": bool}, ..]
   return result
end function
// lexical analyzer end
// cli parser begin
CLIPARSER = {}
CLIPARSER.lexer = LexicalAnalyzer.init
CLIPARSER.lexer.addRule("SPACE", "^[ \t]+", true)
CLIPARSER.lexer.addRule("ENTER", "^[\r\n]", true)
CLIPARSER.lexer.addRule("STRING", "^((?="")(?:""[^""\\]*(?:\\[\s\S][^""\\]*)*""))")
CLIPARSER.lexer.addRule("OTHER", "^[^\s]*")
CLIPARSER.parse = function(input)
    tokens = globals.CLIPARSER.lexer.tokenize(input)
    result = []
    for each_token in tokens
        if each_token.type == "STRING" then
            result.push(each_token["value"][1:-1])
        else
            result.push(each_token["value"])
        end if
    end for
    return result
end function
// cli parser end
// argument parser begin
ArgParser = {"value": null, "flag": null, "opt_value": null}
// arg is optional if defualt != null
// parse arguments in add order
ArgParser.addValue = function(id, desc, default=null) // eg: [local ip] [public ip]
    if default != null then
        self.opt_value.push([id, desc, default])
    else
        self.value.push([id, desc])
    end if
end function
ArgParser.addFlag = function(id, desc) // eg: -t -txz
    self.flag.push([id, desc])
end function
ArgParser.desc = function
    result = ""
    for each_value in self.value
        result = result + "[" + each_value[1] + "] "
    end for
    for each_value in self.opt_value
        result = result + "[opt: " + each_value[1] + ", default: " + each_value[2] + "] "
    end for
    for each_flag in self.flag
        result = result + "[" + each_flag[0] + ": " + each_flag[1] + "] "
    end for
    return result
end function
ArgParser.parse = function(args)
    index = 0
    result = {}
    for each_value in self.value
        if index >= args.len then
            return "Require argument: [" + each_value[1] + "]"
        end if
        if args[index][0] == "-" then
            return "Require argument: [" + each_value[1] + "]. Get flag: " + args[index] + " instead"
        end if
        id = each_value[0]
        if args[index][0] == "$" then
            if globals.ENV_VAR.hasIndex(args[index][1:]) then
                result[id] = globals.ENV_VAR[args[index][1:]]
            else
                result[id] = ""
            end if
        else
            result[id] = args[index]
        end if
        index = index + 1
    end for
    for each_value in self.opt_value
        id = each_value[0]
        if index >= args.len or args[index][0] == "-" then
            result[id] = each_value[2]
            continue
        end if
        if args[index][0] == "$" then
            if globals.ENV_VAR.hasIndex(args[index][1:]) then
                result[id] = globals.ENV_VAR[args[index][1:]]
            else
                result[id] = ""
            end if
        else
            result[id] = args[index]
        end if
        index = index + 1
    end for
    arg_flags = []
    while index < args.len
        if args[index][0] != "-" then
            return "Unknown argument: " + args[index]
        end if
        for each_flag in args[index][1:]
            arg_flags.push(each_flag)
        end for
        index = index + 1
    end while
    for each_flag in self.flag
        id = each_flag[0]
        if arg_flags.indexOf(id[1:]) != null then
            result[id] = true
        else
            result[id] = false
        end if
    end for
    return result
end function
ArgParser.init = function
    result = new ArgParser
    result.value = []
    result.flag = []
    result.opt_value = []
    return result
end function
// argument parser end 
// commmands begin
// system commands begin
COMMANDS = {}
COMMANDS.regCmd = function(cmd, desc="")
    globals.COMMANDS[cmd] = {}
    globals.COMMANDS[cmd]["desc"] = desc
    globals.COMMANDS[cmd]["parser"] = ArgParser.init
end function
COMMANDS.regCmd("help")
COMMANDS["help"].parser.addValue("cmd", "command name", "ALL_COMMAND")
COMMANDS["help"].execute = function(args)
    args = globals.COMMANDS["help"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    if args["cmd"] == "ALL_COMMAND" then
        for each_cmd in globals.COMMANDS.indexes
            if typeof(globals.COMMANDS[each_cmd]) == "map" then
                globals.UTILS.cliPrint(each_cmd)
            end if
        end for
        return
    end if
    if globals.COMMANDS.hasIndex(args["cmd"]) == null then
        return "Command '" + args["cmd"] + "' not found"
    else
        globals.UTILS.cliPrint(globals.COMMANDS[args["cmd"]].desc)
        globals.UTILS.cliPrint("Usage: " + args["cmd"] + " " + globals.COMMANDS[args["cmd"]]["parser"].desc)
    end if
end function
COMMANDS.regCmd("ls")
COMMANDS["ls"].parser.addValue("dir_path", "dir path", ".")
COMMANDS["ls"].parser.addFlag("-l", "Show file details")
COMMANDS["ls"].parser.addFlag("-a", "Show hiden file")
COMMANDS["ls"].execute = function(args)
    args = globals.COMMANDS["ls"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    dir_path = globals.UTILS.resolvePath(args["dir_path"])
    dir = globals.UTILS.getFile(globals.SHELL, dir_path, true)
    if typeof(dir) == "string" then
        return dir
    end if

    sub_files = dir.get_folders + dir.get_files
    output = ""
    for each_sub_file in sub_files
        file_name = each_sub_file.name
        permission = each_sub_file.permissions
        file_owner = each_sub_file.owner
        file_size = each_sub_file.size
        file_group = each_sub_file.group

        if args["-a"] or not file_name[0] == "." then
            if not file_name[0] == "."then
                file_name = globals.COLOR.COMMAND_OUTPUT+each_sub_file.name+"</color>"
            else
                file_name = globals.COLOR.HIDEN_FILE+each_sub_file.name+"</color>"
            end if
            if is_folder(each_sub_file) then file_name = globals.COLOR.FILE+each_sub_file.name+"</color>"

            if output.len > 0 then 
                output = output + "\n"
            end if
            if args["-l"] then
                output = output + globals.COLOR.COMMAND_OUTPUT+ permission + " " + file_owner + " " + file_group + " " + file_size + " 00:00 </color>" + file_name
            else
                output = output + file_name
            end if
        end if
    end for
    
    globals.UTILS.cliPrint(format_columns(output))
end function
COMMANDS.regCmd("cd")
COMMANDS["cd"].parser.addValue("dir_path", "dir path", ".")
COMMANDS["cd"].execute = function(args)
    args = globals.COMMANDS["cd"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    dir_path = globals.UTILS.resolvePath(args["dir_path"])
    dir = globals.UTILS.getFile(globals.SHELL, dir_path, true)
    if typeof(dir) == "string" then
        return dir
    end if

    globals.WORK_DIR = dir.path
end function
COMMANDS.regCmd("cat")
COMMANDS["cat"].parser.addValue("file_path", "file path")
COMMANDS["cat"].execute = function(args)
    args = globals.COMMANDS["cat"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    file_path = globals.UTILS.resolvePath(args["file_path"])
    file = globals.UTILS.getFile(globals.SHELL, file_path)
    if typeof(file) == "string" then
        return file
    end if

    globals.UTILS.cliPrint(file.get_content)
end function
COMMANDS.regCmd("whoami")
COMMANDS["whoami"].execute = function(args)
    globals.UTILS.cliPrint(globals.USER_NAME)
end function
COMMANDS.regCmd("rm")
COMMANDS["rm"].parser.addValue("file_path", "file path")
COMMANDS["rm"].parser.addFlag("-r", "remove directory")
COMMANDS["rm"].execute = function(args)
    args = globals.COMMANDS["rm"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    file_path = globals.UTILS.resolvePath(args["file_path"])
    file = globals.UTILS.getFile(globals.SHELL, file_path, args["-r"])
    if typeof(file) == "string" then
        return file
    end if

    if not file.has_permission("w") then 
        globals.UTILS.cliPrint("Permission denied: " + file.path)
        return
    end if
    file.delete
end function
COMMANDS.regCmd("clear", "clear terminal output")
COMMANDS["clear"].execute = function(args)
    clear_screen
end function
COMMANDS.regCmd("chmod")
COMMANDS["chmod"].parser.addValue("mode", "u,g,o+wrx")
COMMANDS["chmod"].parser.addValue("file_path", "file path")
COMMANDS["chmod"].parser.addFlag("-r", "is recursive")
COMMANDS["chmod"].execute = function(args)
    args = globals.COMMANDS["chmod"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    file_path = globals.UTILS.resolvePath(args["file_path"])
    file = globals.UTILS.getFile(globals.SHELL, file_path, null)
    if typeof(file) == "string" then
        return file
    end if

    result = file.chmod(args["mode"], args["-r"])
    if typeof(result) == "string" then
        globals.UTILS.cliPrint(result)
    else
        return "Permission denied"
    end if
end function
COMMANDS.regCmd("su", "switch user")
COMMANDS["su"].parser.addValue("user", "user name", "root")
COMMANDS["su"].execute = function(args)
    args = globals.COMMANDS["su"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    pub_ip = globals.SHELL.host_computer.public_ip
    loc_ip = globals.SHELL.host_computer.local_ip

    // try cached shell
    shells = globals.SCAN_CACHE.getShell(pub_ip, loc_ip)
    for shell in shells
        username = globals.UTILS.getUser(shell)
        if username == args["user"] then
            globals.UTILS.useShell(shell)
            return
        end if
    end for

    if globals.UTILS.isHost then
        // try cached passwd
        users = globals.SCAN_CACHE.getUser(pub_ip, loc_ip)
        for user in users
            if user["key"] == args["user"] then
                if user["value"].matches("^[a-fA-F0-9]{32}$").len != 0 then
                    passwd = globals.CRYPTO_LIB.decipher(user["value"])
                    globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]] = passwd
                else
                    passwd = globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]]
                end if
                shell = get_shell(args["user"], passwd)
                if shell then 
                    globals.SCAN_CACHE[pub_ip][loc_ip]["shell"].push(shell)
                    globals.UTILS.useShell(shell)
                    return
                else
                    globals.SCAN_CACHE[pub_ip][loc_ip]["user"].remove(user["key"])
                end if
                break
            end if
        end for

        // use input passwd
        passwd = globals.UTILS.cliInput("Password: ", true)
        target_shell = get_shell(args["user"], passwd)
        if not target_shell then 
            return "Authentication failure"
        end if

        if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
            globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
        end if
        globals.SCAN_CACHE[pub_ip][loc_ip]["user"][args["user"]] = passwd 
        globals.SCAN_CACHE[pub_ip][loc_ip]["shell"].push(target_shell) 
        globals.UTILS.useShell(target_shell)
        return
    else
        // try cached passwd
        users = globals.SCAN_CACHE.getUser(pub_ip, loc_ip)
        for user in users
            if user["key"] == args["user"] then
                if user["value"].matches("^[a-fA-F0-9]{32}$").len != 0 then
                    passwd = globals.CRYPTO_LIB.decipher(user["value"])
                    globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]] = passwd
                else
                    passwd = globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]]
                end if
                jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, ["su", args["user"], passwd])
                if typeof(jump) == "string" then
                    return jump
                else if typeof(jump) == "shell" then 
                    globals.SCAN_CACHE[pub_ip][loc_ip]["shell"].push(jump)
                    globals.UTILS.useShell(jump)
                    return
                else
                    globals.SCAN_CACHE[pub_ip][loc_ip]["user"].remove(user["key"])
                end if
                break
            end if
        end for
        // try master key
        if args["user"] == "root" then
            passwd = globals.SCAN_CACHE.getMasterKey(pub_ip)
            if passwd then
                if passwd.matches("^[a-fA-F0-9]{32}$").len != 0 then
                    passwd = globals.CRYPTO_LIB.decipher(passwd)
                end if
                jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, ["su", args["user"], passwd])
                if typeof(jump) == "string" then
                    return jump
                else if typeof(jump) == "shell" then 
                    globals.SCAN_CACHE[pub_ip][loc_ip]["user"][args["user"]] = passwd
                    globals.SCAN_CACHE[pub_ip][loc_ip]["shell"].push(jump)
                    globals.UTILS.useShell(jump)
                    return
                end if
            end if
        end if
        // use input passwd
        passwd = globals.UTILS.cliInput("Password: ", true)
        jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, ["su", args["user"], passwd])
        if typeof(jump) == "string" then
            return jump
        end if

        if typeof(jump) == "shell" then
            globals.UTILS.useShell(jump)
        else
            globals.UTILS.cliPrint("Authentication failure")
            if globals.USER_NAME == "guest" then
                confirm = globals.UTILS.cliInput("Exploit local lib?[y/n]: ", false, true)
                if confirm == "y" then
                    jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, ["lib"])
                    if typeof(jump) == "string" then
                        return jump
                    end if
                    for lib in jump // unsafe indexes
                        libName = lib.lib_name
                        libVersion = lib.version
                        globals.SCAN_CACHE.syncLib(pub_ip, loc_ip, lib)
                        globals.UTILS.cliPrint(libName + " " + libVersion)
                        if not globals.METAX_CACHE.hasLib(libName, libVersion) then
                            for address in globals.METAX_LIB.scan(lib)
                                info = globals.METAX_LIB.scan_address(lib, address).split("Unsafe check: ").replace(char(10), "")
                                for info_line in info
                                    if info_line == info[0] then
                                        continue
                                    end if
                                    zone = info_line[info_line.indexOf("<b>")+3:info_line.indexOf("</b>")]
                                    globals.METAX_CACHE.syncVulner(libName, libVersion, address, zone)
                                end for
                            end for
                        end if
                        for vulner in globals.METAX_CACHE.getVulner(libName, libVersion)
                            address = vulner["key"]
                            zone = vulner["value"]
                            flow = lib.overflow(address, zone)
                            if typeof(flow) != "shell" and typeof(flow) != "computer" and typeof(flow) != "file" then
                                flow = lib.overflow(address, zone, loc_ip)
                            end if
                            globals.SCAN_CACHE.syncItem(pub_ip, loc_ip, flow)
                        end for
                    end for
                end if
            else
                if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
                    globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
                end if
                flag = true
                for shell in globals.SCAN_CACHE[pub_ip][loc_ip]["shell"]
                    if globals.UTILS.getPermission(shell) != "guest" then
                        flag = false
                        break
                    end if
                end for
                if flag then
                    globals.SCAN_CACHE.syncItem(pub_ip, loc_ip, globals.SHELL)
                end if
            end if

            globals.SCAN_CACHE.grabUser(pub_ip, loc_ip)
            for user in globals.SCAN_CACHE[pub_ip][loc_ip]["user"]
                if user["key"] == args["user"] then
                    if user["value"].matches("^[a-fA-F0-9]{32}$").len != 0 then
                        passwd = globals.CRYPTO_LIB.decipher(user["value"])
                        globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]] = passwd
                    else
                        passwd = globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]]
                    end if
                    jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, ["su", args["user"], passwd])
                    if typeof(jump) == "string" then
                        return jump
                    else if typeof(jump) == "shell" then
                        globals.UTILS.useShell(jump)
                        return
                    else
                        return "Failed to crack password"
                    end if
                end if
            end for
            return "No exploit"
        end if
    end if

end function
COMMANDS.regCmd("exit", "back to previous shell")
COMMANDS["exit"].execute = function(args)
    if globals.USED_SHELL.len < 1 then
        confirm = globals.UTILS.cliInput("Exit p1an0Xalpha?[y/n]: ", false, true)
        if confirm == "y" then
            exit
        end if
        return
    end if
    globals.UTILS.exitShell()
end function
COMMANDS.regCmd("env", "show all environment variables")
COMMANDS["env"].execute = function(args)
    for each_var in globals.ENV_VAR.indexes
        globals.UTILS.cliPrint(each_var + "=" + globals.ENV_VAR[each_var])
    end for
end function
COMMANDS.regCmd("export", "add environment variable")
COMMANDS["export"].parser.addValue("var", "variable")
COMMANDS["export"].parser.addValue("value", "value")
COMMANDS["export"].execute = function(args)
    args = globals.COMMANDS["export"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    globals.ENV_VAR[args["var"]] = args["value"]
end function
COMMANDS.regCmd("unset", "remove environment variable")
COMMANDS["unset"].parser.addValue("var", "variable")
COMMANDS["unset"].execute = function(args)
    args = globals.COMMANDS["unset"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    if globals.ENV_VAR.hasIndex(args["var"]) then
        globals.ENV_VAR.remove(args["var"])
    end if
end function
COMMANDS.regCmd("echo")
COMMANDS["echo"].parser.addValue("value", "value")
COMMANDS["echo"].execute = function(args)
    args = globals.COMMANDS["echo"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    globals.UTILS.cliPrint(args["value"])
end function
COMMANDS.regCmd("ifconfig")
COMMANDS["ifconfig"].execute = function(args)
    computer = globals.SHELL.host_computer
    devices = computer.network_devices
    devices_split = devices.split(char(10))[:-1]
    for item in devices_split
        item_split = item.split(" ")
        flag = ""
        if item_split[2] then
            flag = "MONITOR"
        end if
        globals.UTILS.cliPrint(item_split[0] + ": flags=<" + flag + ">")
        globals.UTILS.cliPrint("  chipset " + item_split[1])
    end for
    globals.UTILS.cliPrint("  inet " + computer.local_ip + "  gateway " + computer.network_gateway)
    globals.UTILS.cliPrint("  inet " + computer.public_ip)
    
end function
COMMANDS.regCmd("decipher")
COMMANDS["decipher"].parser.addValue("md5", "md5 hash")
COMMANDS["decipher"].execute = function(args)
    args = globals.COMMANDS["decipher"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    resutl = globals.CRYPTO_LIB.decipher(args["md5"])
    if not resutl then
        return "Invalid md5 hash"
    else
        globals.UTILS.cliPrint(resutl)
    end if
end function
COMMANDS.regCmd("terminal")
COMMANDS["terminal"].execute = function(args)
    globals.SHELL.start_terminal
end function
// system commands end
// hack commands begin
COMMANDS.regCmd("scan", "scan target router and cache result")
COMMANDS["scan"].parser.addValue("ip", "target ip", "")
COMMANDS["scan"].execute = function(args)
    args = globals.COMMANDS["scan"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    if args["ip"].len > 0 and not is_valid_ip(args["ip"]) then
        return "Invalid ip"
    end if
    if args["ip"].len > 0 and not globals.SHELL.ping(args["ip"]) then
        return "Target unreachable"
    end if

    if is_lan_ip(args["ip"]) then
        scan_args = ["scan"]
    else
        scan_args = ["scan", args["ip"]]
    end if
    jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, scan_args)
    if typeof(jump) == "string" then
        return jump
    end if
    if jump == null then
        return "Connection failure"
    end if
    router = jump["router"]
    result = jump["result"]

    pub_ip = router.public_ip
    loc_ip = router.local_ip
    for ip in result.indexes
        for port_num in result[ip]["port"].indexes
            globals.SCAN_CACHE.syncSession(pub_ip, ip, port_num, result[ip]["port"][port_num])
        end for
        for child in result[ip]["children"]
            globals.SCAN_CACHE.syncChild(pub_ip, ip, child)
        end for
    end for

    show_tree = function(ip, depth)
        if outer.result.hasIndex(ip) then
            globals.UTILS.cliPrint(depth + ip + ":")
            for port in outer.result[ip]["port"]
                globals.UTILS.cliPrint(depth + "  " + port["key"] + " " + port["value"].dump_lib.lib_name + " " + port["value"].dump_lib.version)
            end for
            for next_ip in outer.result[ip]["children"]
                show_tree(next_ip, depth+"  ")
            end for
        end if
    end function

    if is_lan_ip(args["ip"]) then
        show_tree(args["ip"], "")
    else
        globals.UTILS.cliPrint("public ip: " + pub_ip + "  local ip: " + loc_ip)
        for port in result[loc_ip]["port"]
            globals.UTILS.cliPrint("  " + port["key"] + " " + port["value"].dump_lib.lib_name + " " + port["value"].dump_lib.version)
        end for
        for ip in result[loc_ip]["children"]
            show_tree(ip, "  ")
        end for
    end if
end function
COMMANDS.regCmd("hack", "exploit net_session or meta_lib")
COMMANDS["hack"].parser.addValue("local_ip", "local ip")
COMMANDS["hack"].parser.addValue("public_ip", "public ip", "")
COMMANDS["hack"].execute = function(args)
    args = globals.COMMANDS["hack"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    
    pub_ip = args["public_ip"]
    if pub_ip.len == 0 then
        pub_ip = globals.SHELL.host_computer.public_ip
    end if
    loc_ip = args["local_ip"]
    if not is_valid_ip(pub_ip) or is_lan_ip(pub_ip) then
        return "Invalid public ip"
    end if
    if not is_lan_ip(loc_ip) then
        return "Invalid local ip"
    end if

    meta_libs = []
    is_bounce = []
    if globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        for net_session in globals.SCAN_CACHE[pub_ip][loc_ip]["port"].values
            meta_libs.push(net_session.dump_lib)
            is_bounce.push(false)
        end for
        for lib in globals.SCAN_CACHE[pub_ip][loc_ip]["lib"]
            meta_libs.push(lib)
            is_bounce.push(false)
        end for
    end if
    for router_ip in globals.SCAN_CACHE.getRouters(pub_ip, loc_ip)
        for net_session in globals.SCAN_CACHE[pub_ip][router_ip]["port"].values
            meta_libs.push(net_session.dump_lib)
            is_bounce.push(true)
        end for
    end for

    if meta_libs.len == 0 then
        return "No open port or local lib"
    end if
    vulners = {}
    for metaLib in meta_libs
        libName = metaLib.lib_name
        libVersion = metaLib.version
        globals.UTILS.cliPrint(libName + " " + libVersion)
        if not globals.METAX_CACHE.hasLib(libName, libVersion) then
            for address in globals.METAX_LIB.scan(metaLib)
                info = globals.METAX_LIB.scan_address(metaLib, address).split("Unsafe check: ").replace(char(10), "")
                for info_line in info
                    if info_line == info[0] then continue
                    zone = info_line[info_line.indexOf("<b>")+3:info_line.indexOf("</b>")]
                    globals.METAX_CACHE.syncVulner(libName, libVersion, address, zone)
                end for
            end for
        end if

        if not vulners.hasIndex(libName) then
            vulners[libName] = {}
        end if
        if not vulners[libName].hasIndex(libVersion) then
            vulners[libName][libVersion] = {}
        end if
        vulners[libName][libVersion] = globals.METAX_CACHE.getVulner(libName, libVersion)
    end for
    jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, ["hack", args["local_ip"], args["public_ip"]], {"meta_libs": meta_libs, "vulners": vulners, "is_bounce": is_bounce})
    if typeof(jump) == "string" then
        return jump
    end if
    for item in jump
        globals.SCAN_CACHE.syncItem(pub_ip, loc_ip, item)
    end for

    globals.SCAN_CACHE.grabUser(pub_ip, loc_ip)
    globals.SCAN_CACHE.grabMail(pub_ip, loc_ip)
    shells = globals.SCAN_CACHE[pub_ip][loc_ip]["shell"]
    mails = globals.SCAN_CACHE[pub_ip][loc_ip]["mail"]
    users = globals.SCAN_CACHE[pub_ip][loc_ip]["user"]
    
    if mails.len > 0 then
        globals.UTILS.cliPrint("mail: ")
        for mail in mails
            globals.UTILS.cliPrint("  " + mail["key"] + " " + mail["value"])
        end for
    end if
    if users.len > 0 then
        globals.UTILS.cliPrint("user: ")
        for user in users
            globals.UTILS.cliPrint("  " + user["key"] + " " + user["value"])
        end for
    end if
    if shells.len > 0 then
        globals.UTILS.cliPrint("shell: ")
        for index in shells.indexes
            shell = shells[index]
            user = globals.UTILS.getUser(shell)
            globals.UTILS.cliPrint("  " + index + ")" + user)
        end for
        use = to_int(globals.UTILS.cliInput("use: "))
        if typeof(use) == "number" or use >= 0 and use < shells.len then
            globals.UTILS.useShell(shells[use])
        end if
    end if
    if mails.len == 0 and shells.len == 0 then
        return "No exploit"
    end if
end function
COMMANDS.regCmd("jump", "make jumpfile on target shell")
COMMANDS["jump"].execute = function(args)
    jump = globals.UTILS.makeJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME)
    if typeof(jump) == "string" then
        return jump
    end if
    upload = scp(get_shell, globals.METAX_PATH, globals.ENV_VAR.JUMP_PATH, globals.SHELL)
    if upload != true then
        return upload
    end if
end function
COMMANDS.regCmd("clog", "clear log of all shell")
COMMANDS["clog"].execute = function(args)
    result = {}
    shells = [globals.SHELL]
    for shell in globals.USED_SHELL
        shells.push(shell[0])
    end for
    for shell in shells
        replace_file = globals.UTILS.writeFile(shell, "/var", "p1an0Xalpha", "p1an0Xalpha")
        ip = shell.host_computer.public_ip + " " + shell.host_computer.local_ip
        if typeof(replace_file) == "string" then
            if not result.hasIndex(ip) or result[ip] != "success" then
                result[ip] = replace_file
            end if
            continue
        end if
        replace_file = globals.UTILS.getFile(shell, "/var/p1an0Xalpha")
        if typeof(replace_file) == "string" then
            if not result.hasIndex(ip) or result[ip] != "success" then
                result[ip] = replace_file
            end if
            continue
        end if
        mv = replace_file.move("/var", "system.log")
        if typeof(mv) == "string" then
            if not result.hasIndex(ip) or result[ip] != "success" then
                result[ip] = mv
            end if
            continue
        end if
        result[ip] = "success"
    end for
    for ip in result.indexes
        globals.UTILS.cliPrint(ip + ": " + result[ip])
    end for
end function
// hack commands end
// gsi commands begin
COMMANDS.regCmd("gsi", "greyscript interpreter")
COMMANDS["gsi"].parser.addValue("code", "code string")
COMMANDS["gsi"].execute = function(args)
    args = globals.COMMANDS["gsi"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    
end function
// gsi commands end
// commands end
// main loop begin
getInput = function()
    suffix = "$"
    show_path = globals.WORK_DIR[:len(globals.HOME_DIR)].replace(globals.HOME_DIR, "~") + globals.WORK_DIR[len(globals.HOME_DIR):]
    if globals.USER_NAME == "root" then
        suffix = "#"
        show_path = globals.WORK_DIR
    end if
    output = char(10)+globals.COLOR.SHELL_BAR+"<pos=05>———(</color><b>"+globals.COLOR.SHELL_USER+globals.USER_NAME+"@"+globals.HOST_NAME+"</color></b>"+globals.COLOR.SHELL_BAR+")—[</color><b>"+globals.COLOR.SHELL_PATH+show_path+"</b>"+globals.COLOR.SHELL_BAR+"]<voffset=-0.5em>"+"<pos=00>|<voffset=-1em><space=-0.6em>|<voffset=-1.5em><pos=05>——<b></color>"+globals.COLOR.SHELL_USER+suffix+"</color></b>"+globals.COLOR.SHELL_INPUT+" "
    return user_input(output)
end function
executeCommand = function(command, arguments)
    if not globals.COMMANDS.hasIndex(command) then
        return "Command '"+command+"' not found"
    end if
    return globals.COMMANDS[command].execute(arguments)
end function
while true
    input = getInput
    if not input then continue

    parsed_input = globals.CLIPARSER.parse(input)
    execute_result = executeCommand(parsed_input[0], parsed_input[1:])
    if typeof(execute_result) == "string" then
        globals.UTILS.cliPrint(execute_result)
    end if
end while
// main loop end
// gsi begin
// lexer begin
GSILEXER = LexicalAnalyzer.init
GSILEXER.addRule("SPACE", "^[ \t]+", true)
GSILEXER.addRule("ENTER", "^[\r\n]")
GSILEXER.addRule("COMMENT", "^\/\/.*(?=\n|\r|$)", true)
GSILEXER.addRule("EQUALS", "^==")
GSILEXER.addRule("NOT_EQ", "^!=")
GSILEXER.addRule("GT_EQ", "^>=")
GSILEXER.addRule("LT_EQ", "^<=")
GSILEXER.addRule("ASSIGN", "^=")
GSILEXER.addRule("LESS_THAN", "^<")
GSILEXER.addRule("GREATER_THAN", "^>")
GSILEXER.addRule("COLON", "^:")
GSILEXER.addRule("ADD", "^\+")
GSILEXER.addRule("MINUS", "^-")
GSILEXER.addRule("DIV", "^\/")
GSILEXER.addRule("MOD", "^%")
GSILEXER.addRule("STAR", "^\*")
GSILEXER.addRule("COMMA", "^,");
GSILEXER.addRule("SEMI_COLON", "^;")
GSILEXER.addRule("DOT", "^\.")
GSILEXER.addRule("AT", "^@")
GSILEXER.addRule("OPEN_PAREN", "^\(")
GSILEXER.addRule("CLOSE_PAREN", "^\)")
GSILEXER.addRule("OPEN_BRACE", "^\{")
GSILEXER.addRule("CLOSE_BRACE", "^\}")
GSILEXER.addRule("OPEN_BRACKET", "^\[")
GSILEXER.addRule("CLOSE_BRACKET", "^\]")
GSILEXER.addRule("IF", "^if(?![A-Za-z0-9_])")
GSILEXER.addRule("THEN", "^then(?![A-Za-z0-9_])")
GSILEXER.addRule("ELSE", "^else(?![A-Za-z0-9_])")
GSILEXER.addRule("WHILE", "^while(?![A-Za-z0-9_])")
GSILEXER.addRule("FOR", "^for(?![A-Za-z0-9_])")
GSILEXER.addRule("FUNCTION", "^function(?![A-Za-z0-9_])")
GSILEXER.addRule("NEW", "^new(?![A-Za-z0-9_])")
GSILEXER.addRule("RETURN", "^return(?![A-Za-z0-9_])")
GSILEXER.addRule("END", "^end(?![A-Za-z0-9_])")
GSILEXER.addRule("IN", "^in(?![A-Za-z0-9_])")
GSILEXER.addRule("AND", "^and(?![A-Za-z0-9_])")
GSILEXER.addRule("OR", "^or(?![A-Za-z0-9_])")
GSILEXER.addRule("NOT", "^not(?![A-Za-z0-9_])")
GSILEXER.addRule("NULL", "^null(?![A-Za-z0-9_])")
GSILEXER.addRule("TRUE", "^true(?![A-Za-z0-9_])")
GSILEXER.addRule("FALSE", "^false(?![A-Za-z0-9_])")
GSILEXER.addRule("IDENTIFIER", "^[A-Za-z_][A-Za-z0-9_]*")
GSILEXER.addRule("STRING", "^((?="")(?:""[^""\\]*(?:\\[\s\S][^""\\]*)*""))")
GSILEXER.addRule("NUMBER", "^-?\d+(\.\d+)?")
// lexer end
// gsi parser begin
GSItoken_idx = 0
GSIidx_stack = []
GSInode_stack = []
GSIast_stack = []
GSItokens = []
GSIastRelation = function(current_ast, last_ast)
    if current_ast == null or last_ast == null then
        return "other"
    end if

    last_ts = last_ast.type_stack
    current_ts = current_ast.type_stack
    if last_ts.len == current_ts.len then
        for i in last_ts.indexes
            if last_ts[i] != current_ts[i] then
                return "other"
            end if
        end for
        if current_ts[-1] == current_ast.type then
            return "child"
        else 
            return "brother"
        end if
    else if last_ts.len == current_ts.len - 1 then
        full_ts = last_ts + [last_ast.type]
        for i in full_ts.indexes
            if full_ts[i] != current_ts[i] then
                return "other"
            end if
        end for
        return "child"
    else
        return "other"
    end if
end function
GSIPARSE = function(code_string)
    tokens = globals.GSILEXER.tokenize(code_string)
    globals.GSItoken_idx = 0
    globals.GSIidx_stack = [0]
    globals.GSInode_stack = []
    globals.GSIast_stack = []
    globals.GSItokens = tokens
    globals.GSInode_stack.push([greyscript])

    while globals.GSInode_stack.len > 0 and globals.GSItoken_idx < globals.GSItokens.len
        nodes = globals.GSInode_stack[-1]
        globals.GSItoken_idx = globals.GSIidx_stack[-1]

        if nodes.len <= 0 or nodes[0] == null then
            globals.GSInode_stack.pop
            globals.GSIast_stack.pop
            globals.GSIidx_stack.pop
            continue
        end if

        // print globals.GSItoken_idx
        // print globals.GSItokens[globals.GSItoken_idx]
        tmp = []
        for each_nodes in globals.GSInode_stack
            debug = []
            for each in each_nodes
                debug.push(each.type)
            end for
            tmp.push(debug)
        end for
        // print tmp
        // print globals.GSIidx_stack
        // wait(1)

        while nodes.len > 0
            each_node = nodes.pull
            func_result = each_node.expand_func()
            next_node = each_node.next_node
            type_stack = each_node.type_stack
            ignore = each_node.ignore
            // print each_node.type
            // print "each result:"
            if typeof(func_result) == "list" then
                tmp2 = []
                for each_next_node in func_result
                    tmp2.push(each_next_node.type)
                end for
                // print tmp2
            else
                // print func_result
            end if
            if typeof(func_result) == "list" then
                globals.GSInode_stack.push(func_result)
                globals.GSIast_stack.push({"type": each_node.type, "type_stack": type_stack, "items": [], "ignore": ignore})
                globals.GSIidx_stack.push(globals.GSItoken_idx)
                break
            else if func_result.flag == true then
                globals.GSInode_stack.push([next_node])
                result_items = func_result["items"]
                if func_result.ignore then
                    result_items = []
                end if
                globals.GSIast_stack.push({"type": each_node.type, "type_stack": type_stack, "items": result_items, "ignore": ignore})
                globals.GSIidx_stack.push(globals.GSItoken_idx)
                break
            else if func_result.flag == false then
                globals.GSItoken_idx = globals.GSIidx_stack[-1]
            end if
        end while
        
    end while
    if globals.GSItoken_idx == globals.GSItokens.len then
        // print "YES!"
        index = globals.GSIast_stack.len - 1
        while globals.GSIast_stack.len > 1
            prev_ast = null
            if index+1 < globals.GSIast_stack.len then
                prev_ast = globals.GSIast_stack[index-1]
            end if
            current_ast = globals.GSIast_stack[index]
            next_ast = null
            if index+1 < globals.GSIast_stack.len then
                next_ast = globals.GSIast_stack[index+1]
            end if
            
            // merge if cureent_ast is leaf
            prev_relation = globals.GSIastRelation(current_ast, prev_ast)
            next_relation =  globals.GSIastRelation(next_ast, current_ast)
            if current_ast.type == "epsilonNode" then
                globals.GSIast_stack.remove(index)
            else if prev_relation == "child" and next_relation != "child" then
                current_ast.remove("type_stack")
                if current_ast.items.len != 0 then
                    if current_ast.ignore then
                        prev_ast.items = prev_ast.items + current_ast.items
                    else
                        current_ast.remove("ignore")
                        prev_ast.items.push(current_ast)
                    end if
                end if
                globals.GSIast_stack.remove(index)
            else 
                index = index - 1
            end if
        end while
        ast = globals.GSIast_stack[0]
        ast.remove("ignore")
        ast.remove("type_stack")
        // print toJSON(globals.GSIast_stack[0])
    end if
end function
// start basic function
requireType = function(types, result_type, ignore)
    items = []
    if typeof(types) == "string" then
        types = [types]
    end if
    for each_type in types
        if globals.GSItoken_idx >= globals.GSItokens.len or globals.GSItokens[globals.GSItoken_idx]["type"] != each_type then
            return {"flag": false, "type": result_type}
        end if
        current_token = globals.GSItokens[globals.GSItoken_idx]
        each_range = {"start": [current_token["loc"][0], current_token["loc"][1]-current_token["value"].len], "end": current_token["loc"]}
        items.push({"token_value": current_token["value"], "token_type": current_token["type"], "range": each_range})
        globals.GSItoken_idx = globals.GSItoken_idx + 1
    end for
    // ranges = {"start": [items[0]["range"]["start"][0], items[0]["range"]["start"][1]], "end": items[-1]["range"]["end"]}
    return {"flag": true, "type": result_type, "items": items, "ignore": ignore}
end function
requireValue = function(value, result_type, ignore)
    items = []
    if typeof(value) == "string" then
        value = [value]
    end if
    for each_value in value
        if globals.GSItoken_idx >= globals.GSItokens.len or globals.GSItokens[globals.GSItoken_idx]["value"] != each_value then
            return {"flag": false, "type": result_type}
        end if
        current_token = globals.GSItokens[globals.GSItoken_idx]
        each_range = {"start": [current_token["loc"][0], current_token["loc"][1]-current_token["value"].len], "end": current_token["loc"]}
        items.push({"token_value": current_token["value"], "token_type": current_token["type"], "range": each_range})
        globals.GSItoken_idx = globals.GSItoken_idx + 1
    end for
    // ranges = {"start": [items[0]["range"]["start"][0], items[0]["range"]["start"][1]], "end": items[-1]["range"]["end"]}
    return {"flag": true, "type": result_type, "items": items, "ignore": ignore}
end function
// expand_func(): list[GSINode] | {"flag": flag, "type": type, "items": items, "range": range}
GSINode = {"expand_func": null, "next_node": null, "type_stack": [],"type": null, "ignore": false}
GSINode.series = function(nodes)
    result_nodes = []
    last_node = new nodes[-1]
    last_node.next_node = self.next_node
    last_node.type_stack = self.type_stack + [self.type]
    result_nodes.push(last_node)

    for i in range(nodes.len-2, 0, -1)
        each_node = new nodes[i]
        each_node.next_node = result_nodes[-1]
        each_node.type_stack = self.type_stack + [self.type]
        result_nodes.push(each_node)
    end for

    return [result_nodes[-1]]
end function
GSINode.parallel = function(nodes)
    result_nodes = []
    for i in nodes.indexes
        each_node = new nodes[i]
        each_node.next_node = self.next_node
        each_node.type_stack = self.type_stack + [self.type]
        result_nodes.push(each_node)
    end for
    return result_nodes
end function
GSINode.optional = function(node)
    return self.parallel([node, epsilonNode])
end function
// require expand_func_bak
GSINode.any = function(node)
    if self.hasIndex("expand_func_bak") then
        exit("Error: no expand_func_bak for node: " + self.type)
    end if
    result_node = new node
    result_node.next_node_bak = self.next_node
    result_node.next_node = result_node
    result_node.type_stack = self.type_stack + [self.type]

    result_node.expand_func = function()
        tmp_epsilonNode = new epsilonNode
        tmp_epsilonNode.next_node = result_node.next_node_bak
        tmp_epsilonNode.type_stack = result_node.type_stack + [result_node.type]
        return result_node.expand_func_bak + [tmp_epsilonNode]
    end function
    return [result_node]
end function

greyscript = new GSINode
greyscript.type = "greyscript"
greyscript.expand_func = function()
    return self.any(codeBlock)
end function
codeBlock = new GSINode
codeBlock.type = "codeBlock"
codeBlock.ignore = true
codeBlock.expand_func_bak = function()
    return self.parallel([requireEOL, variableDeclaration, ifStatement, forStatement, whileStatement, returnStatement, expressionStatement])
end function
variableDeclaration = new GSINode
variableDeclaration.type = "variableDeclaration"
variableDeclaration.expand_func = function()
    return self.series([requireIdentifier, requireAssign, objectExpression, requireEOL])
end function
// address of expression start
addressOfExpression = new GSINode
addressOfExpression.type = "addressOfExpression"
addressOfExpression.expand_func = function()
    return self.series([requireAt, objectExpression])
end function
// address of expression end
// expression statement start
expressionStatement = new GSINode
expressionStatement.type = "expressionStatement"
expressionStatement.expand_func = function()
   return self.series([objectExpression, requireEOL])
end function
// expression statement end
objectExpression = new GSINode
objectExpression.type = "objectExpression"
objectExpression.ignore = true
objectExpression.expand_func = function()
   return self.parallel([requireIdentifier, requireString, requireNumber, requireNull, requireTrue, requireFalse, addressOfExpression, listExpression, mapExpression, callExpression, evalExpression, funcExpression, newExpression])
end function
evalAtom = new GSINode
evalAtom.type = "evalAtom"
evalAtom.ignore = true
evalAtom.expand_func = function()
   return self.parallel([requireIdentifier, requireString, requireNumber, requireNull, requireTrue, requireFalse, listExpression, mapExpression, pri1EvalExpression, pri2EvalExpression, newExpression, callExpression])
end function
memberAtom = new GSINode
memberAtom.type = "memberAtom"
memberAtom.ignore = true
memberAtom.expand_func = function()
   return self.parallel([requireIdentifier, requireString, requireNumber, requireNull, requireTrue, requireFalse, listExpression, mapExpression, pri1EvalExpression])
end function
callAtom = new GSINode
callAtom.type = "memberAtom"
callAtom.ignore = true
callAtom.expand_func = function()
   return self.parallel([requireIdentifier, memberExpression])
end function
// list expression start
listClause = new GSINode
listClause.type = "listClause"
listClause.ignore = true
listClause.expand_func_bak = function
    return self.series([requireComma, objectExpression])
end function
listClauses = new GSINode
listClauses.type = "listClauses"
listClauses.ignore = true
listClauses.expand_func = function
    return self.any(listClause)
end function
listElements = new GSINode
listElements.type = "listElements"
listElements.ignore = true
listElements.expand_func = function()
   return self.series([objectExpression, listClauses])
end function
optListElements = new GSINode
optListElements.type = "optListElements"
optListElements.ignore = true
optListElements.expand_func = function()
   return self.parallel([listElements, epsilonNodeNoIgnore])
end function
listExpression = new GSINode
listExpression.type = "listExpression"
listExpression.expand_func = function()
   return self.series([requireOpenBracket, optListElements, requireCloseBracket])
end function
// list expression end
// map expression start
mapClause = new GSINode
mapClause.type = "mapClause"
mapClause.ignore = true
mapClause.expand_func_bak = function
    return self.series([requireComma, pairExpression])
end function
mapClauses = new GSINode
mapClauses.type = "mapClauses"
mapClauses.ignore = true
mapClauses.expand_func = function
    return self.any(mapClause)
end function
pairExpression = new GSINode
pairExpression.type = "pairExpression"
pairExpression.expand_func = function()
   return self.series([objectExpression, requireColon, objectExpression])
end function
mapElements = new GSINode
mapElements.type = "mapElements"
mapElements.ignore = true
mapElements.expand_func = function()
   return self.series([pairExpression, mapClauses])
end function
optMapElements = new GSINode
optMapElements.type = "optMapElements"
optMapElements.ignore = true
optMapElements.expand_func = function()
   return self.parallel([mapElements, epsilonNodeNoIgnore])
end function
mapExpression = new GSINode
mapExpression.type = "mapExpression"
mapExpression.expand_func = function()
   return self.series([requireOpenBrace, optMapElements, requireCloseBrace])
end function
// map expression end
// reserved string start
epsilonNode = new GSINode
epsilonNode.type = "epsilonNode"
epsilonNode.ignore = true
epsilonNode.expand_func = function()
    return {"flag": true, "type": self.type, "range": null, "items": null, "ignore": self.ignore}
end function
epsilonNodeNoIgnore = new GSINode
epsilonNodeNoIgnore.type = "epsilonNodeNoIgnore"
epsilonNodeNoIgnore.expand_func = function()
    return {"flag": true, "type": self.type, "range": null, "items": [null], "ignore": self.ignore}
end function
requireIdentifier = new GSINode
requireIdentifier.type = "requireIdentifier"
requireIdentifier.expand_func = function
   return requireType("IDENTIFIER", self.type, self.ignore)
end function
requireAssign = new GSINode
requireAssign.type = "requireAssign"
requireAssign.ignore = true
requireAssign.expand_func = function()
   return requireType("ASSIGN", self.type, self.ignore)
end function
requireString = new GSINode
requireString.type = "requireString"
requireString.expand_func = function()
   return requireType("STRING", self.type, self.ignore)
end function
requireNumber = new GSINode
requireNumber.type = "requireNumber"
requireNumber.expand_func = function()
   return requireType("NUMBER", self.type, self.ignore)
end function
requireOpenBracket = new GSINode
requireOpenBracket.type = "requireOpenBracket"
requireOpenBracket.ignore = true
requireOpenBracket.expand_func = function()
   return requireType("OPEN_BRACKET", self.type, self.ignore)
end function
requireCloseBracket = new GSINode
requireCloseBracket.type = "requireCloseBracket"
requireCloseBracket.ignore = true
requireCloseBracket.expand_func = function()
   return requireType("CLOSE_BRACKET", self.type, self.ignore)
end function
requireOpenParen = new GSINode
requireOpenParen.type = "requireOpenParen"
requireOpenParen.ignore = true
requireOpenParen.expand_func = function()
   return requireType("OPEN_PAREN", self.type, self.ignore)
end function
requireCloseParen = new GSINode
requireCloseParen.type = "requireCloseParen"
requireCloseParen.ignore = true
requireCloseParen.expand_func = function()
   return requireType("CLOSE_PAREN", self.type, self.ignore)
end function
requireOpenBrace = new GSINode
requireOpenBrace.type = "requireOpenBrace"
requireOpenBrace.ignore = true
requireOpenBrace.expand_func = function()
   return requireType("OPEN_BRACE", self.type, self.ignore)
end function
requireCloseBrace = new GSINode
requireCloseBrace.type = "requireCloseBrace"
requireCloseBrace.ignore = true
requireCloseBrace.expand_func = function()
   return requireType("CLOSE_BRACE", self.type, self.ignore)
end function
requireComma = new GSINode
requireComma.type = "requireComma"
requireComma.ignore = true
requireComma.expand_func = function()
   return requireType("COMMA", self.type, self.ignore)
end function
requireColon = new GSINode
requireColon.type = "requireColon"
requireColon.ignore = true
requireColon.expand_func = function()
   return requireType("COLON", self.type, self.ignore)
end function
requireDot = new GSINode
requireDot.type = "requireDot"
requireDot.ignore = true
requireDot.expand_func = function()
   return requireType("DOT", self.type, self.ignore)
end function
requireAt = new GSINode
requireAt.type = "requireAt"
requireAt.ignore = true
requireAt.expand_func = function()
   return requireType("AT", self.type, self.ignore)
end function
requireEnter = new GSINode
requireEnter.type = "requireEnter"
requireEnter.ignore = true
requireEnter.expand_func = function()
   return requireType("ENTER", self.type, self.ignore)
end function
requireSemiColon = new GSINode
requireSemiColon.type = "requireSemiColon"
requireSemiColon.ignore = true
requireSemiColon.expand_func = function()
   return requireType("SEMI_COLON", self.type, self.ignore)
end function
requireEOL = new GSINode
requireEOL.type = "requireEOL"
requireEOL.ignore = true
requireEOL.expand_func = function()
   return self.parallel([requireEnter, requireSemiColon])
end function
requireNull = new GSINode
requireNull.type = "requireNull"
requireNull.expand_func = function()
   return requireType("NULL", self.type, self.ignore)
end function
requireTrue = new GSINode
requireTrue.type = "requireTrue"
requireTrue.expand_func = function()
   return requireType("TRUE", self.type, self.ignore)
end function
requireFalse = new GSINode
requireFalse.type = "requireFalse"
requireFalse.expand_func = function()
   return requireType("FALSE", self.type, self.ignore)
end function
requireIf = new GSINode
requireIf.type = "requireIf"
requireIf.ignore = true
requireIf.expand_func = function()
   return requireType("IF", self.type, self.ignore)
end function
requireThen = new GSINode
requireThen.type = "requireThen"
requireThen.ignore = true
requireThen.expand_func = function()
   return requireType("THEN", self.type, self.ignore)
end function
requireElse = new GSINode
requireElse.type = "requireElse"
requireElse.ignore = true
requireElse.expand_func = function()
   return requireType("ELSE", self.type, self.ignore)
end function
requireWhile = new GSINode
requireWhile.type = "requireWhile"
requireWhile.ignore = true
requireWhile.expand_func = function()
   return requireType("WHILE", self.type, self.ignore)
end function
requireFor = new GSINode
requireFor.type = "requireFor"
requireFor.ignore = true
requireFor.expand_func = function()
   return requireType("FOR", self.type, self.ignore)
end function
requireFuncion = new GSINode
requireFuncion.type = "requireFuncion"
requireFuncion.ignore = true
requireFuncion.expand_func = function()
   return requireType("FUNCTION", self.type, self.ignore)
end function
requireNew = new GSINode
requireNew.type = "requireNew"
requireNew.ignore = true
requireNew.expand_func = function()
   return requireType("NEW", self.type, self.ignore)
end function
requireReturn = new GSINode
requireReturn.type = "requireReturn"
requireReturn.ignore = true
requireReturn.expand_func = function()
   return requireType("RETURN", self.type, self.ignore)
end function
requireEnd = new GSINode
requireEnd.type = "requireEnd"
requireEnd.ignore = true
requireEnd.expand_func = function()
   return requireType("END", self.type, self.ignore)
end function
requireIn = new GSINode
requireIn.type = "requireIn"
requireIn.ignore = true
requireIn.expand_func = function()
   return requireType("IN", self.type, self.ignore)
end function
// reserved string end
// math operator start
requireStar = new GSINode
requireStar.type = "requireStar"
requireStar.expand_func = function()
   return requireType("STAR", self.type, self.ignore)
end function
requireDiv = new GSINode
requireDiv.type = "requireDiv"
requireDiv.expand_func = function()
   return requireType("DIV", self.type, self.ignore)
end function
requireMod = new GSINode
requireMod.type = "requireMod"
requireMod.expand_func = function()
   return requireType("MOD", self.type, self.ignore)
end function
requireAdd = new GSINode
requireAdd.type = "requireAdd"
requireAdd.expand_func = function()
   return requireType("ADD", self.type, self.ignore)
end function
requireMinus = new GSINode
requireMinus.type = "requireMinus"
requireMinus.expand_func = function()
   return requireType("MINUS", self.type, self.ignore)
end function
// math operator end
// logical operator start
requireEquals = new GSINode
requireEquals.type = "requireEquals"
requireEquals.expand_func = function()
   return requireType("EQUALS", self.type, self.ignore)
end function
requireNoteq = new GSINode
requireNoteq.type = "requireNoteq"
requireNoteq.expand_func = function()
   return requireType("NOT_EQ", self.type, self.ignore)
end function
requireGteq = new GSINode
requireGteq.type = "requireGteq"
requireGteq.expand_func = function()
   return requireType("GT_EQ", self.type, self.ignore)
end function
requireLteq = new GSINode
requireLteq.type = "requireLteq"
requireLteq.expand_func = function()
   return requireType("LT_EQ", self.type, self.ignore)
end function
requireGt = new GSINode
requireGt.type = "requireGt"
requireGt.expand_func = function()
   return requireType("GREATER_THAN", self.type, self.ignore)
end function
requireLt = new GSINode
requireLt.type = "requireLt"
requireLt.expand_func = function()
   return requireType("LESS_THAN", self.type, self.ignore)
end function
requireNot = new GSINode
requireNot.type = "requireNot"
requireNot.expand_func = function()
   return requireType("NOT", self.type, self.ignore)
end function
requireAnd = new GSINode
requireAnd.type = "requireAnd"
requireAnd.expand_func = function()
   return requireType("AND", self.type, self.ignore)
end function
requireOr = new GSINode
requireOr.type = "requireOr"
requireOr.expand_func = function()
   return requireType("OR", self.type, self.ignore)
end function
// logical operator end
// eval expression start
optObjectExpression = new GSINode
optObjectExpression.type = "optObjectExpression"
optObjectExpression.ignore = true
optObjectExpression.expand_func = function()
    return self.parallel([epsilonNodeNoIgnore, objectExpression])
end function
pri1EvalExpression = new GSINode
pri1EvalExpression.type = "pri1EvalExpression"
pri1EvalExpression.expand_func = function() // ()
   return self.series([requireOpenParen, optObjectExpression, requireCloseParen])
end function
pri2Operator = new GSINode
pri2Operator.type = "pri2Operator"
pri2Operator.ignore = true
pri2Operator.expand_func = function()
   return self.parallel([requireNot, requireMinus])
end function
pri2EvalExpression = new GSINode
pri2EvalExpression.type = "pri2EvalExpression"
pri2EvalExpression.expand_func = function() // not + -
   return self.series([pri2Operator, objectExpression])
end function
pri3Operator = new GSINode
pri3Operator.type = "pri3Operator"
pri3Operator.ignore = true
pri3Operator.expand_func = function()
   return self.parallel([requireStar, requireDiv, requireMod])
end function
mdmEvalExpression = new GSINode
mdmEvalExpression.type = "mdmEvalExpression"
mdmEvalExpression.expand_func_bak = function()
    return self.series([pri3Operator, evalAtom])
end function
anyMdmEval = new GSINode
anyMdmEval.type = "anyMdmEval"
anyMdmEval.ignore = true
anyMdmEval.expand_func = function()
    return self.any(mdmEvalExpression)
end function
pri3EvalExpression = new GSINode
pri3EvalExpression.type = "pri3EvalExpression"
pri3EvalExpression.ignore = true
pri3EvalExpression.expand_func = function() // * /  %
   return self.series([evalAtom, anyMdmEval])
end function
pri4Operator = new GSINode
pri4Operator.type = "pri4Operator"
pri4Operator.ignore = true
pri4Operator.expand_func = function()
   return self.parallel([requireAdd, requireMinus])
end function
amEvalExpression = new GSINode
amEvalExpression.type = "amEvalExpression"
amEvalExpression.expand_func_bak = function() // + -
   return self.series([pri4Operator, pri3EvalExpression])
end function
anyAmEval = new GSINode
anyAmEval.type = "anyAmEval"
anyAmEval.ignore = true
anyAmEval.expand_func = function() // + -
   return self.any(amEvalExpression)
end function
pri4EvalExpression = new GSINode
pri4EvalExpression.type = "pri4EvalExpression"
pri4EvalExpression.ignore = true
pri4EvalExpression.expand_func = function() // + -
   return self.series([pri3EvalExpression, anyAmEval])
end function
pri5Operator = new GSINode
pri5Operator.type = "pri5Operator"
pri5Operator.ignore = true
pri5Operator.expand_func = function()
   return self.parallel([requireGteq, requireLteq, requireGt, requireLt])
end function
compEvalExpression = new GSINode
compEvalExpression.type = "compEvalExpression"
compEvalExpression.expand_func_bak = function() // >= <= > <
   return self.series([pri5Operator, pri4EvalExpression])
end function
anyCompEval = new GSINode
anyCompEval.type = "anyCompEval"
anyCompEval.ignore = true
anyCompEval.expand_func = function() // >= <= > <
   return self.any(compEvalExpression)
end function
pri5EvalExpression = new GSINode
pri5EvalExpression.type = "pri5EvalExpression"
pri5EvalExpression.ignore = true
pri5EvalExpression.expand_func = function() // >= <= > <
   return self.series([pri4EvalExpression, anyCompEval])
end function
pri6Operator = new GSINode
pri6Operator.type = "pri6Operator"
pri6Operator.ignore = true
pri6Operator.expand_func = function()
   return self.parallel([requireEquals, requireNoteq])
end function
weqEvalExpression = new GSINode
weqEvalExpression.type = "weqEvalExpression"
weqEvalExpression.expand_func_bak = function() // != ==
   return self.series([pri6Operator, pri5EvalExpression])
end function
anyWeqEval = new GSINode
anyWeqEval.type = "anyWeqEval"
anyWeqEval.ignore = true
anyWeqEval.expand_func = function() // != ==
   return self.any(weqEvalExpression)
end function
pri6EvalExpression = new GSINode
pri6EvalExpression.type = "pri6EvalExpression"
pri6EvalExpression.ignore = true
pri6EvalExpression.expand_func = function() // != ==
   return self.series([pri5EvalExpression, anyWeqEval])
end function
andEvalExpression = new GSINode
andEvalExpression.type = "andEvalExpression"
andEvalExpression.expand_func_bak = function() // and
   return self.series([requireAnd, pri6EvalExpression])
end function
anyAndEval = new GSINode
anyAndEval.type = "anyAndEval"
anyAndEval.ignore = true
anyAndEval.expand_func = function() // and
   return self.any(andEvalExpression)
end function
pri7EvalExpression = new GSINode
pri7EvalExpression.type = "pri7EvalExpression"
pri7EvalExpression.ignore = true
pri7EvalExpression.expand_func = function() // and
   return self.series([pri6EvalExpression, anyAndEval])
end function
orEvalExpression = new GSINode
orEvalExpression.type = "orEvalExpression"
orEvalExpression.expand_func_bak = function() // or
   return self.series([requireOr, pri7EvalExpression])
end function
anyOrEval = new GSINode
anyOrEval.type = "anyOrEval"
anyOrEval.ignore = true
anyOrEval.expand_func = function() // or
   return self.any(orEvalExpression)
end function
pri8EvalExpression = new GSINode
pri8EvalExpression.type = "pri8EvalExpression"
pri8EvalExpression.ignore = true
pri8EvalExpression.expand_func = function() // or
   return self.series([pri7EvalExpression, anyOrEval])
end function
evalExpression = new GSINode
evalExpression.type = "evalExpression"
evalExpression.expand_func = function()
    return self.parallel([pri8EvalExpression])
end function
// eval expression end
// if statement start
ifStatement = new GSINode
ifStatement.type = "ifStatement"
ifStatement.expand_func = function()
    return self.series([requireIf, evalExpression, requireThen, requireEOL, ifConsequent, anyElifStatement, optElseStatement, requireEnd, requireIf, requireEOL])
end function
ifConsequent = new GSINode
ifConsequent.type = "ifConsequent"
ifConsequent.expand_func = function()
    return self.any(codeBlock)
end function
ifAlternate = new GSINode
ifAlternate.type = "ifAlternate"
ifAlternate.expand_func = function()
    return self.any(codeBlock)
end function
elseStatement = new GSINode
elseStatement.type = "elseStatement"
elseStatement.ignore = true
elseStatement.expand_func = function()
    return self.series([requireElse, requireEOL, ifAlternate])
end function
optElseStatement = new GSINode
optElseStatement.type = "optElseStatement"
optElseStatement.ignore = true
optElseStatement.expand_func = function()
    return self.optional(elseStatement)
end function
elifStatement = new GSINode
elifStatement.type = "elifStatement"
elifStatement.expand_func_bak = function()
    return self.series([requireElse, requireIf, evalExpression, requireThen, requireEOL, ifAlternate])
end function
anyElifStatement = new GSINode
anyElifStatement.type = "anyElifStatement"
anyElifStatement.ignore = true
anyElifStatement.expand_func = function()
    return self.any(elifStatement)
end function
// if statement end
// for statement start
forCodeBlock = new GSINode
forCodeBlock.type = "forCodeBlock"
forCodeBlock.expand_func = function()
    return self.any(codeBlock)
end function
forStatement = new GSINode
forStatement.type = "forStatement"
forStatement.expand_func = function()
    return self.series([requireFor, requireIdentifier, requireIn, objectExpression, requireEOL, forCodeBlock, requireEnd, requireFor, requireEOL])
end function
// for statement end
// while statement start
whileCodeBlock = new GSINode
whileCodeBlock.type = "whileCodeBlock"
whileCodeBlock.expand_func = function()
    return self.any(codeBlock)
end function
whileStatement = new GSINode
whileStatement.type = "whileStatement"
whileStatement.expand_func = function()
    return self.series([requireWhile, evalExpression, requireEOL, whileCodeBlock, requireEnd, requireWhile, requireEOL])
end function
// function expression start
paramAtom = new GSINode
paramAtom.type = "paramAtom"
paramAtom.ignore = true
paramAtom.expand_func = function()
    return self.parallel([requireString, requireNumber, requireNull, requireTrue, requireFalse])
end function
paramDefault = new GSINode
paramDefault.type = "paramDefault"
paramDefault.ignore = true
paramDefault.expand_func = function()
    return self.series([requireAssign, paramAtom])
end function
optParamDefault = new GSINode
optParamDefault.type = "optParamDefault"
optParamDefault.ignore = true
optParamDefault.expand_func = function()
    return self.optional(paramDefault)
end function
funcParam = new GSINode
funcParam.type = "funcParam"
funcParam.expand_func = function()
    return self.series([requireIdentifier, optParamDefault])
end function
funcParamClause = new GSINode
funcParamClause.type = "funcParamClause"
funcParamClause.ignore = true
funcParamClause.expand_func_bak = function
    return self.series([requireComma, funcParam])
end function
funcParamClauses = new GSINode
funcParamClauses.type = "funcParamClauses"
funcParamClauses.ignore = true
funcParamClauses.expand_func = function
    return self.any(funcParamClause)
end function
funcParamParen = new GSINode
funcParamParen.type = "funcParamParen"
funcParamParen.ignore = true
funcParamParen.expand_func = function
    return self.series([funcParam, funcParamClauses])
end function
optFuncParamParen = new GSINode
optFuncParamParen.type = "optFuncParamParen"
optFuncParamParen.ignore = true
optFuncParamParen.expand_func = function
    return self.parallel([epsilonNodeNoIgnore, funcParamParen])
end function
funcParams = new GSINode
funcParams.type = "funcParams"
funcParams.expand_func = function()
   return self.series([requireOpenParen, optFuncParamParen, requireCloseParen])
end function
optFuncParams = new GSINode
optFuncParams.type = "optFuncParams"
optFuncParams.ignore = true
optFuncParams.expand_func = function()
   return self.parallel([epsilonNodeNoIgnore, funcParams])
end function
funcCodeBlock = new GSINode
funcCodeBlock.type = "funcCodeBlock"
funcCodeBlock.expand_func = function()
    return self.any(codeBlock)
end function
funcExpression = new GSINode
funcExpression.type = "funcExpression"
funcExpression.expand_func = function()
    return self.series([requireFuncion, optFuncParams, requireEOL, funcCodeBlock, requireEnd, requireFuncion])
end function
// function expression end
// return statement start
returnStatement = new GSINode
returnStatement.type = "returnStatement"
returnStatement.expand_func = function()
    return self.series([requireReturn, optObjectExpression, requireEOL])
end function
// return statement end
// call expression start
callParamClause = new GSINode
callParamClause.type = "callParamClause"
callParamClause.ignore = true
callParamClause.expand_func_bak = function
    return self.series([requireComma, objectExpression])
end function
callParamClauses = new GSINode
callParamClauses.type = "callParamClauses"
callParamClauses.ignore = true
callParamClauses.expand_func = function
    return self.any(callParamClause)
end function
callParamParen = new GSINode
callParamParen.type = "callParamParen"
callParamParen.ignore = true
callParamParen.expand_func = function
    return self.series([objectExpression, callParamClauses])
end function
optCallParamParen = new GSINode
optCallParamParen.type = "optCallParamParen"
optCallParamParen.ignore = true
optCallParamParen.expand_func = function
    return self.parallel([epsilonNodeNoIgnore, callParamParen])
end function
callParamsWithParen = new GSINode
callParamsWithParen.type = "callParamsWithParen"
callParamsWithParen.ignore = true
callParamsWithParen.expand_func = function()
   return self.series([requireOpenParen, optCallParamParen, requireCloseParen])
end function
callParams = new GSINode
callParams.type = "callParams"
callParams.expand_func = function()
   return self.parallel([epsilonNodeNoIgnore, callParamsWithParen])
end function
callExpression = new GSINode
callExpression.type = "callExpression"
callExpression.expand_func = function()
    return self.series([callAtom, callParams])
end function
// call expression end
// member expression start
dotMember = new GSINode
dotMember.type = "dotMember"
dotMember.ignore = true
dotMember.expand_func = function()
    return self.series([requireDot, requireIdentifier])
end function
bracketPair = new GSINode
bracketPair.type = "bracketPair"
bracketPair.expand_func = function()
   return self.series([optObjectExpression, requireColon, optObjectExpression])
end function
indexBracketMember = new GSINode
indexBracketMember.type = "indexBracketMember"
indexBracketMember.ignore = true
indexBracketMember.expand_func = function()
    return self.parallel([objectExpression, bracketPair])
end function
bracketMember = new GSINode
bracketMember.type = "bracketMember"
bracketMember.ignore = true
bracketMember.expand_func = function()
    return self.series([requireOpenBracket, indexBracketMember, requireCloseBracket])
end function
dbMember = new GSINode
dbMember.type = "dbMember"
dbMember.ignore = true
dbMember.expand_func_bak = function()
    return self.parallel([dotMember, bracketMember])
end function
anyDbMember = new GSINode
anyDbMember.type = "anyDbMember"
anyDbMember.expand_func = function()
    return self.any(dbMember)
end function
memberExpression = new GSINode
memberExpression.type = "memberExpression"
memberExpression.expand_func = function()
    return self.series([memberAtom, anyDbMember])
end function
// member expression end
// new expression start
newExpression = new GSINode
newExpression.type = "newExpression"
newExpression.expand_func = function()
    return self.series([requireNew, objectExpression])
end function
// gsi parser end
// gsi end