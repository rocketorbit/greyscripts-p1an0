// environment variable begin
ENV_VAR = {}
ENV_VAR.JUMP_PATH = "/home/guest"
ENV_VAR.JUMP_NAME = "jumpfile"
// environment variable end
// global variables begin
SHELL = get_shell
WORK_DIR = current_path
USER_NAME = function
    return globals.UTILS.getUser(globals.SHELL)
end function
HOST_NAME = function
    return globals.SHELL.host_computer.get_name
end function
HOME_DIR = function
    if globals.USER_NAME == "root" then
        return "/root"
    else
        return "/home/" + globals.USER_NAME
    end if
end function
USED_SHELL = []
METAX_PATH = "/lib/metaxploit.so"
METAX_LIB = include_lib(METAX_PATH)
if not METAX_LIB then
    METAX_PATH = current_path + "/metaxploit.so"
    METAX_LIB = include_lib(METAX_PATH)
end if
CRYPTO_LIB = include_lib("/lib/crypto.so")
if not CRYPTO_LIB then
    CRYPTO_LIB = include_lib(current_path + "/crypto.so")
end if
// global variables end
// cache begin
SCAN_CACHE = {}
// SCAN_CACHE = {
//     public_ip: {
//         local_ip: {
//             "port": {port_num: net_session, ...},
//             "lib": [metaLib, ...],
//             "shell" : [shell, ...],
//             "computer": [commputer, ...],
//             "file": [file, ...],
//             "user": {username: passwd, ...},
//             "mail": {account: passwd, ...},
//             "bank": {account: passwd, ...}
//         },
//         ...
//     },
//     ...
// }
SCAN_CACHE.hasMachine = function(pub_ip, loc_ip)
    return globals.SCAN_CACHE.hasIndex(pub_ip) and globals.SCAN_CACHE[pub_ip].hasIndex(loc_ip)
end function
SCAN_CACHE.syncMachine = function(pub_ip, loc_ip)
    if not globals.SCAN_CACHE.hasIndex(pub_ip) then
        globals.SCAN_CACHE[pub_ip] = {}
    end if
    globals.SCAN_CACHE[pub_ip][loc_ip] = {"port": {}, "lib": [], "shell": [], "computer": [], "file": [], "user": {}, "mail": {}, "bank": {}}
end function
SCAN_CACHE.syncSession = function(pub_ip, loc_ip, port_num, net_session)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    globals.SCAN_CACHE[pub_ip][loc_ip]["port"][port_num] = net_session
end function
SCAN_CACHE.syncLib = function(pub_ip, loc_ip, meta_lib)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    globals.SCAN_CACHE[pub_ip][loc_ip]["lib"].push(meta_lib)
end function
SCAN_CACHE.syncItem = function(pub_ip, loc_ip, item)
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
    end if
    if typeof(item) == "shell" then
        globals.SCAN_CACHE[pub_ip][loc_ip]["shell"].push(item)
    else if typeof(item) == "computer" then
        globals.SCAN_CACHE[pub_ip][loc_ip]["computer"].push(item)
    else if typeof(item) == "file" then
        globals.SCAN_CACHE[pub_ip][loc_ip]["file"].push(item)
    end if
end function
SCAN_CACHE.getUser = function(pub_ip, loc_ip)
    if globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        return globals.SCAN_CACHE[pub_ip][loc_ip]["user"]
    else
        return {}
    end if
end function
SCAN_CACHE.getShell = function(pub_ip, loc_ip)
    if globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        return globals.SCAN_CACHE[pub_ip][loc_ip]["shell"]
    else
        return []
    end if
end function
SCAN_CACHE.grabUser = function(pub_ip, loc_ip)
    if globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        items = globals.SCAN_CACHE[pub_ip][loc_ip]["shell"] + globals.SCAN_CACHE[pub_ip][loc_ip]["computer"] + globals.SCAN_CACHE[pub_ip][loc_ip]["file"]
        for item in items
            file = globals.UTILS.getFile(item, "/etc/passwd")
            if typeof(file) == "file" and file.get_content != null then
                file_split = file.get_content.split("\n")
                for user in file_split
                    if user.len == 0 then
                        continue
                    end if
                    user_split = user.split(":")
                    globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user_split[0]] = user_split[1]
                end for
                break
            end if
        end for
    end if
end function
SCAN_CACHE.grabMail = function(pub_ip, loc_ip)
    if globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        items = globals.SCAN_CACHE[pub_ip][loc_ip]["shell"] + globals.SCAN_CACHE[pub_ip][loc_ip]["computer"] + globals.SCAN_CACHE[pub_ip][loc_ip]["file"]
        for item in items
            user = globals.UTILS.getUser(item)
            if user == "root" then
                home = globals.UTILS.getFile(item, "/home")
                if typeof(home) == "file" then
                    for user_dir in home.get_folders
                        if user_dir.name != "guest" then
                            file = globals.UTILS.getFile(item, "/home/"+user_dir.name+"/Config/Mail.txt")
                            if typeof(file) == "file" and file.get_content != null then
                                file_split = file.get_content.split("\n")
                                for mail in file_split
                                    if mail.len == 0 then
                                        continue
                                    end if
                                    mail_split = mail.split(":")
                                    globals.SCAN_CACHE[pub_ip][loc_ip]["mail"][mail_split[0]] = mail_split[1]
                                end for
                            end if
                        end if
                    end for
                end if
                break
            else if user != "guest" then
                file = globals.UTILS.getFile(item, "/home/"+user+"/Config/Mail.txt")
                if typeof(file) == "file" and file.get_content != null then
                    file_split = file.get_content.split("\n")
                    for mail in file_split
                        if mail.len == 0 then
                            continue
                        end if
                        mail_split = mail.split[":"]
                        globals.SCAN_CACHE[pub_ip][loc_ip]["mail"][mail_split[0]] = mail_split[1]
                    end for
                end if
            end if
        end for
    end if
end function
SCAN_CACHE.grabBank = function(pub_ip, loc_ip)
    if globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        items = globals.SCAN_CACHE[pub_ip][loc_ip]["shell"] + globals.SCAN_CACHE[pub_ip][loc_ip]["computer"] + globals.SCAN_CACHE[pub_ip][loc_ip]["file"]
        for item in items
            user = globals.UTILS.getUser(item)
            if user == "root" then
                home = globals.UTILS.getFile(item, "/home")
                if typeof(home) == "file" then
                    for user_dir in home.get_folders
                        if user_dir.name != "guest" then
                            file = globals.UTILS.getFile(item, "/home/"+user_dir.name+"/Config/Bank.txt")
                            if typeof(file) == "file" and file.get_content != null then
                                file_split = file.get_content.split("\n")
                                for bank in file_split
                                    if bank.len == 0 then
                                        continue
                                    end if
                                    bank_split = bank.split(":")
                                    globals.SCAN_CACHE[pub_ip][loc_ip]["bank"][bank_split[0]] = bank_split[1]
                                end for
                            end if
                        end if
                    end for
                end if
                break
            else if user != "guest" then
                file = globals.UTILS.getFile(item, "/home/"+user+"/Config/Bank.txt")
                if typeof(file) == "file" and file.get_content != null then
                    file_split = file.get_content.split("\n")
                    for bank in file_split
                        if bank.len == 0 then
                            continue
                        end if
                        bank_split = bank.split[":"]
                        globals.SCAN_CACHE[pub_ip][loc_ip]["bank"][bank_split[0]] = bank_split[1]
                    end for
                end if
            end if
        end for
    end if
end function
METAX_CACHE = {}
// METAX_CACHE = {
//     name: {
//         version: {
//             address: zone,
//             ...
//         },
//         ...
//     },
//     ...
// }
METAX_CACHE.hasLib = function(libName, libVersion)
    return globals.METAX_CACHE.hasIndex(libName) and globals.METAX_CACHE[libName].hasIndex(libVersion)
end function
METAX_CACHE.syncVulner = function(libName, libVersion, address, zone)
    if not globals.METAX_CACHE.hasIndex(libName) then
        globals.METAX_CACHE[libName] = {}
    end if
    if not globals.METAX_CACHE[libName].hasIndex(libVersion) then
        globals.METAX_CACHE[libName][libVersion] = {}
    end if
    globals.METAX_CACHE[libName][libVersion][address] = zone
end function
METAX_CACHE.getVulner = function(libName, libVersion)
    if not globals.METAX_CACHE.hasLib(libName, libVersion) then
        return {}
    else
        return globals.METAX_CACHE[libName][libVersion]
    end if
end function
// cache end
// color begin
COLOR = {}
COLOR.FILE = "<color=#6F6FEE>"
COLOR.HIDEN_FILE = "<color=#9479B3>"
COLOR.ROOT_PREV = "<color=#D15858>"
COLOR.USER_PREV = "<color=#6F6FEE>"
COLOR.GUEST_PREV = "<color=#C6CF99>"
COLOR.SHELL_PATH = "<color=white>"
COLOR.SHELL_BAR = "<color=#3590C5>"
COLOR.SHELL_INPUT = "<color=#9CD3D9>"
COLOR.SHELL_USER = function
    perm = globals.UTILS.getPermission(globals.SHELL)
    if perm == "root" then
        return globals.COLOR.ROOT_PREV
    else if perm == "user" then
        return globals.COLOR.USER_PREV
    else
        return globals.COLOR.GUEST_PREV
    end if
end function
COLOR.COMMAND_OUTPUT = "<color=white>"
// color end
// utils begin
UTILS = {}
UTILS.getFile = function(item, file_path, is_folder_flag=false)
    if typeof(item) == "shell" then
        result_file = item.host_computer.File(file_path)
        if not result_file then
            return "No such file or directory"
        else if not is_folder(result_file) and is_folder_flag == true then
            return "Not a directory" 
        else if is_folder(result_file) and is_folder_flag == false then
            return "Is a directory"
        else
            return result_file
        end if 
    else if typeof(item) == "computer" then
        result_file = item.File(file_path)
        if not result_file then
            return "No such file or directory"
        else if not is_folder(result_file) and is_folder_flag == true then
            return "Not a directory" 
        else if is_folder(result_file) and is_folder_flag == false then
            return "Is a directory"
        else
            return result_file
        end if 
    else if typeof(item) == "file" then
        item_parent = item.parent
        while item_parent
            item = item_parent
            item_parent = item.parent
        end while
        path_split = file_path.split("/")[1:]
        for each_split in path_split[:-1]
            for each_folder in item.get_folders
                if each_folder.name == each_split then
                    item = each_folder
                    break
                end if
            end for
        end for
        if is_folder_flag == true then
            for each_folder in item.get_folders
                if each_folder.name == path_split[-1] then
                    item = each_folder
                    break
                end if
            end for
        else if is_folder_flag == false then
            for each_file in item.get_files
                if each_file.name == path_split[-1] then
                    item = each_file
                    break
                end if
            end for
        else
            for each_folder in item.get_folders
                if each_folder.name == path_split[-1] then
                    item = each_folder
                    break
                end if
            end for
            for each_file in item.get_files
                if each_file.name == path_split[-1] then
                    item = each_file
                    break
                end if
            end for
        end if
        if not item or item.path != file_path then
            return "No such file or directory"
        else if not item.has_permission("r") then
            return "Permission denied"
        else if not is_folder(item) and is_folder_flag == true then
            return "Not a directory" 
        else if is_folder(item) and is_folder_flag == false then
            return "Is a directory"
        else
            return item
        end if
    else
        return "Requrie shell, computer, or file"
    end if
end function
UTILS.getPermission = function(item)
    passwd_file = null
    if typeof(item) == "shell" then
        passwd_file = item.host_computer.File("/etc/passwd")
    else if typeof(item) == "computer" then
        passwd_file = item.File("/etc/passwd")
    else if typeof(item) == "file" then
        passwd_file = globals.UTILS.getFile(item, "/etc/passwd")
    end if

    if typeof(passwd_file) == "file" then
        if passwd_file.has_permission("w") then
            return "root"
        else if not passwd_file.has_permission("r") then
            return "guest"
        else
            return "user"
        end if
    else
        return null
    end if
end function
UTILS.writeFile = function(item, file_path, file_name, content)
    file = globals.UTILS.getFile(item, file_path + "/" + file_name)
    if typeof(file) == "string" then
        if file == "No such file or directory" then
            file = "Failed to create file"
            if typeof(item) == "shell" then
                file = item.host_computer.touch(file_path, file_name)
            else if typeof(item) == "computer" then
                file = item.touch(file_path, file_name)
            end if
            if typeof(file) == "string" then
                return file
            else
                file = globals.UTILS.getFile(item, file_path + "/" + file_name)
                if typeof(file) == "string" then
                    return file
                end if
                result = file.set_content(content)
                if result != true then
                    return result
                end if
            end if
        else
            return file
        end if
    else
        result = file.set_content(content)
        if result != true then
            return result
        end if
    end if
end function
UTILS.getUser = function(item)
    perm = globals.UTILS.getPermission(item)
    if perm == "root" then
        return "root"
    else if perm == "guest" then
        return "guest"
    else
        dir = globals.UTILS.getFile(item, "/home", true)
        if typeof(dir) == "string" then
            return null
        end if
        for each_folder in dir.get_folders
            if each_folder.has_permission("w") then
                return each_folder.name
            end if
        end for 
    end if
end function
UTILS.resolvePath = function(relative_path)
    result_path = null
    if relative_path == null or relative_path.len <= 0 then
        result_path = globals.WORK_DIR
    else if relative_path[0] == "/" then
        result_path = relative_path
    else if relative_path[0] == "~" and (relative_path.len <= 1 or relative_path[1] == "/") then
        result_path = globals.HOME_DIR + relative_path[1:]
    else if globals.WORK_DIR == "/" then
        result_path = globals.WORK_DIR + relative_path
    else
        result_path = globals.WORK_DIR + "/" + relative_path
    end if

    path_split = result_path.split("/")[1:]
    index = 0
    while index < path_split.len
        if path_split[index] == "." or path_split[index] == "" then
            path_split.remove(index)
            index = index - 1
        else if path_split[index] == ".." then
            if index - 1 >= 0 then
                path_split.remove(index - 1)
                path_split.remove(index - 1)
                index = index - 2
            else
                path_split.remove(index)
                index = index - 1
            end if
        end if
        index = index + 1
    end while

    result_path = ""
    for each_split in path_split
        result_path = result_path + "/" + each_split
    end for
    if result_path.len == 0 then
        result_path = "/"
    end if
    return result_path
end function
UTILS.useShell = function(target_shell)
    globals.USED_SHELL.push([globals.SHELL, globals.WORK_DIR])
    globals.SHELL = target_shell
    globals.WORK_DIR = globals.HOME_DIR
end function
UTILS.exitShell = function()
    used_shell = globals.USED_SHELL.pop
    globals.SHELL = used_shell[0]
    globals.WORK_DIR = used_shell[1]
end function
UTILS.isHost = function()
    return globals.SHELL.host_computer.public_ip == get_shell.host_computer.public_ip and globals.SHELL.host_computer.local_ip == get_shell.host_computer.local_ip
end function
UTILS.cliPrint = function(message)
    print(globals.COLOR.COMMAND_OUTPUT+message+"</color>")
end function
UTILS.cliInput = function(message, is_pass=false, any_key=false)
    return user_input(globals.COLOR.COMMAND_OUTPUT+message, is_pass, any_key)
end function
UTILS.makeJumpfile = function(shell, jump_path, file_name)
    jump_src = "
    metax = include_lib(current_path+""/metaxploit.so"")
    cmd = params[0]
    if cmd == ""su"" then
        username = params[1]
        passwd = params[2]
        shell = get_shell(username, passwd)
        get_custom_object[cmd] = shell
    else if cmd == ""scan"" then
        router = get_router
        if params.len > 1 and params[1].len > 0 then
            router = get_router(params[1])
        end if
        if not router then
            get_custom_object[cmd] = null
            exit
        end if
        result = {}
        for ip in router.devices_lan_ip
            result[ip] = {}
            ports = router.device_ports(ip)
            if typeof(ports) == ""list"" then
                for port in ports
                    port_num = port.port_number
                    net_session = metax.net_use(ip, port_num)
                    if not net_session then
                        continue
                    end if
                    if port.get_lan_ip == ip then
                        result[ip][port_num] = net_session
                    else
                        if not result.hasIndex(port.get_lan_ip) then
                            result[port.get_lan_ip] = {}
                        end if
                        result[port.get_lan_ip][port_num] = net_session
                    end if
                end for
            end if
        end for
        result[router.local_ip][0] = metax.net_use(router.local_ip, 0)
        get_custom_object[cmd] = {""result"": result, ""router"": router}
    else if cmd == ""lib"" then
        lib_dir = get_shell.host_computer.File(""/lib"")
        if lib_dir then
            get_custom_object[cmd] = []
            for file in lib_dir.get_files
                lib = metax.load(file.path)
                if lib then
                    get_custom_object[cmd].push(lib)
                end if
            end for
        else
            get_custom_object[cmd] = null
        end if
    end if
    "
    write = globals.UTILS.writeFile(shell, jump_path, file_name + ".src", jump_src)
    if typeof(write) == "string" then
        return write
    end if
    compile = shell.build(jump_path + "/" + file_name + ".src", jump_path)
    if compile.len != 0 then
        return compile
    end if
end function
UTILS.useJumpfile = function(shell, jump_path, file_name, args) // unsafe custom.indexes
    args_string = ""
    for arg in args
        args_string = args_string + arg  + " "
    end for
    for index in get_custom_object.indexes
        get_custom_object.remove(@index)
    end for

    jumpfile_path = jump_path + "/" + file_name

    run = shell.launch(jumpfile_path, args_string)
    if run != true then
        make = globals.UTILS.makeJumpfile(shell, jump_path, file_name)
        if typeof(make) == "string" then
            return make
        end if

        run = shell.launch(jumpfile_path, args_string)
        if run != true then
            return "Failed to launch jumpfile"
        end if
    end if
    if args[0] == "lib" or args[0] == "scan" then
        metax = globals.UTILS.getFile(shell, jump_path + "/metaxploit.so")
        if typeof(metax) != "file" then
            upload = scp(get_shell, globals.METAX_PATH, jump_path, shell)
            if upload != true then
                return upload
            end if
        end if
    end if

    custom = get_custom_object
    cmd = args[0]
    if cmd == "su" and custom.hasIndex(cmd) then
        if typeof(@custom[cmd]) == "shell" or typeof(@custom[cmd]) == "null" then
            return custom[cmd]
        else
            return "Jumpfile error: su"
        end if
    else if cmd == "scan" and custom.hasIndex(cmd) then
        if typeof(@custom["scan"]) == "null" then
            return custom["scan"]
        end if
        if typeof(@custom["scan"]) == "map" and custom["scan"].hasIndex("router") and typeof(@custom["scan"]["router"]) == "router" then
            if custom["scan"].hasIndex("result") and typeof(@custom["scan"]["result"]) == "map" then
                for loc_ip in custom["scan"]["result"].indexes
                    if typeof(@loc_ip) == "string" and typeof(@custom["scan"]["result"][loc_ip]) == "map" then
                        for port_num in custom["scan"]["result"][loc_ip].indexes
                            if typeof(@port_num) != "number" or typeof(@custom["scan"]["result"][loc_ip][port_num]) != "NetSession" then
                                return "Jumpfile error1"
                            end if
                        end for
                    else
                        return "Jumpfile error2"
                    end if
                end for
                return custom["scan"]
            else
                return "Jumpfile error4"
            end if
        else
            return "Jumpfile error5"
        end if
    else if cmd == "lib" and custom.hasIndex(cmd) and typeof(@custom[cmd]) == "list" then
        for lib in custom[cmd]
            if typeof(@lib) != "MetaLib" then
                return "Jumpfile error: lib"
            end if
        end for
        return custom[cmd]
    else
        return "Jumpfile error: cmd"
    end if
end function
// utils end
// lexcial analyzer begin
LexicalAnalyzer = {}
LexicalAnalyzer.tokenize = function(expression)
   result = [] // [{"type": type, "value": value, "loc": [line, colume]}, ...]
   line = 0
   colume = 0
   while expression
      for each_rule in self.rules
         type = each_rule["type"]
         ignore = each_rule["ignore"]
         value = null

         for each_regex in each_rule["regex"]
            regex_result = expression.matches(each_regex)
            for each in regex_result.indexes
               value = regex_result[each]
               break
            end for
            if value then break
         end for

         if value then
            colume = colume + value.len
            if type == "ENTER" then
               line = line + 1
               colume = 0
            end if
            expression = expression[value.len:]
            if ignore then break
            result.push({"type": type, "value": value, "loc": [line, colume]})
            break
         end if
      end for
   end while
   return result
end function
LexicalAnalyzer.addRule = function(type, regex, ignore=false)
    if typeof(regex) != "list" then
        regex = [regex]
    end if
    self["rules"].push({"type": type, "regex": regex, "ignore": ignore})
end function
LexicalAnalyzer.init = function
   result = new LexicalAnalyzer
   result["rules"] = [] // [{"type": type, "regex": [regex, ...], "ignore": bool}, ..]
   result.addRule("SPACE", "^[ \t]+", true)
   result.addRule("ENTER", "^[\r\n]", true)
   return result
end function
// lexical analyzer end
// cli parser begin
CLIPARSER = {}
CLIPARSER.lexer = LexicalAnalyzer.init
CLIPARSER.lexer.addRule("STRING", "^((?="")(?:""[^""\\]*(?:\\[\s\S][^""\\]*)*""))")
CLIPARSER.lexer.addRule("OTHER", "^[^\s]*")
CLIPARSER.parse = function(input)
    tokens = globals.CLIPARSER.lexer.tokenize(input)
    result = []
    for each_token in tokens
        if each_token.type == "STRING" then
            result.push(each_token["value"][1:-1])
        else
            result.push(each_token["value"])
        end if
    end for
    return result
end function
// cli parser end
// argument parser begin
ArgParser = {"value": null, "flag": null, "opt_value": null}
// arg is optional if defualt != null
// parse arguments in add order
ArgParser.addValue = function(id, desc, default=null) // eg: [local ip] [public ip]
    if default != null then
        self.opt_value.push([id, desc, default])
    else
        self.value.push([id, desc])
    end if
end function
ArgParser.addFlag = function(id, desc) // eg: -t -txz
    self.flag.push([id, desc])
end function
ArgParser.desc = function
    result = ""
    for each_value in self.value
        result = result + "[" + each_value[1] + "] "
    end for
    for each_value in self.opt_value
        result = result + "[opt: " + each_value[1] + ", default: " + each_value[2] + "] "
    end for
    for each_flag in self.flag
        result = result + "[" + each_flag[0] + ": " + each_flag[1] + "] "
    end for
    return result
end function
ArgParser.parse = function(args)
    index = 0
    result = {}
    for each_value in self.value
        if index >= args.len then
            return "Require argument: [" + each_value[1] + "]"
        end if
        if args[index][0] == "-" then
            return "Require argument: [" + each_value[1] + "]. Get flag: " + args[index] + " instead"
        end if
        id = each_value[0]
        if args[index][0] == "$" then
            if globals.ENV_VAR.hasIndex(args[index][1:]) then
                result[id] = globals.ENV_VAR[args[index][1:]]
            else
                result[id] = ""
            end if
        else
            result[id] = args[index]
        end if
        index = index + 1
    end for
    for each_value in self.opt_value
        id = each_value[0]
        if index >= args.len or args[index][0] == "-" then
            result[id] = each_value[2]
            continue
        end if
        if args[index][0] == "$" then
            if globals.ENV_VAR.hasIndex(args[index][1:]) then
                result[id] = globals.ENV_VAR[args[index][1:]]
            else
                result[id] = ""
            end if
        else
            result[id] = args[index]
        end if
        index = index + 1
    end for
    arg_flags = []
    while index < args.len
        if args[index][0] != "-" then
            return "Unknown argument: " + args[index]
        end if
        for each_flag in args[index][1:]
            arg_flags.push(each_flag)
        end for
        index = index + 1
    end while
    for each_flag in self.flag
        id = each_flag[0]
        if arg_flags.indexOf(id[1:]) != null then
            result[id] = true
        else
            result[id] = false
        end if
    end for
    return result
end function
ArgParser.init = function
    result = new ArgParser
    result.value = []
    result.flag = []
    result.opt_value = []
    return result
end function
// argument parser end 
// commmands begin
// system commands begin
COMMANDS = {}
COMMANDS.regCmd = function(cmd, desc="")
    globals.COMMANDS[cmd] = {}
    globals.COMMANDS[cmd]["desc"] = desc
    globals.COMMANDS[cmd]["parser"] = ArgParser.init
end function
COMMANDS.regCmd("help")
COMMANDS["help"].parser.addValue("cmd", "command name", "ALL_COMMAND")
COMMANDS["help"].execute = function(args)
    args = globals.COMMANDS["help"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    if args["cmd"] == "ALL_COMMAND" then
        for each_cmd in globals.COMMANDS.indexes
            if typeof(globals.COMMANDS[each_cmd]) == "map" then
                globals.UTILS.cliPrint(each_cmd)
            end if
        end for
        return
    end if
    if globals.COMMANDS.hasIndex(args["cmd"]) == null then
        return "Command '" + args["cmd"] + "' not found"
    else
        globals.UTILS.cliPrint(globals.COMMANDS[args["cmd"]].desc)
        globals.UTILS.cliPrint("Usage: " + args["cmd"] + " " + globals.COMMANDS[args["cmd"]]["parser"].desc)
    end if
end function
COMMANDS.regCmd("ls")
COMMANDS["ls"].parser.addValue("dir_path", "dir path", ".")
COMMANDS["ls"].parser.addFlag("-l", "Show file details")
COMMANDS["ls"].parser.addFlag("-a", "Show hiden file")
COMMANDS["ls"].execute = function(args)
    args = globals.COMMANDS["ls"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    dir_path = globals.UTILS.resolvePath(args["dir_path"])
    dir = globals.UTILS.getFile(globals.SHELL, dir_path, true)
    if typeof(dir) == "string" then
        return dir
    end if

    sub_files = dir.get_folders + dir.get_files
    output = ""
    for each_sub_file in sub_files
        file_name = each_sub_file.name
        permission = each_sub_file.permissions
        file_owner = each_sub_file.owner
        file_size = each_sub_file.size
        file_group = each_sub_file.group

        if args["-a"] or not file_name[0] == "." then
            if not file_name[0] == "."then
                file_name = globals.COLOR.COMMAND_OUTPUT+each_sub_file.name+"</color>"
            else
                file_name = globals.COLOR.HIDEN_FILE+each_sub_file.name+"</color>"
            end if
            if is_folder(each_sub_file) then file_name = globals.COLOR.FILE+each_sub_file.name+"</color>"

            if output.len > 0 then 
                output = output + "\n"
            end if
            if args["-l"] then
                output = output + globals.COLOR.COMMAND_OUTPUT+ permission + " " + file_owner + " " + file_group + " " + file_size + " 00:00 </color>" + file_name
            else
                output = output + file_name
            end if
        end if
    end for
    
    globals.UTILS.cliPrint(format_columns(output))
end function
COMMANDS.regCmd("cd")
COMMANDS["cd"].parser.addValue("dir_path", "dir path", ".")
COMMANDS["cd"].execute = function(args)
    args = globals.COMMANDS["cd"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    dir_path = globals.UTILS.resolvePath(args["dir_path"])
    dir = globals.UTILS.getFile(globals.SHELL, dir_path, true)
    if typeof(dir) == "string" then
        return dir
    end if

    globals.WORK_DIR = dir.path
end function
COMMANDS.regCmd("cat")
COMMANDS["cat"].parser.addValue("file_path", "file path")
COMMANDS["cat"].execute = function(args)
    args = globals.COMMANDS["cat"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    file_path = globals.UTILS.resolvePath(args["file_path"])
    file = globals.UTILS.getFile(globals.SHELL, file_path)
    if typeof(file) == "string" then
        return file
    end if

    globals.UTILS.cliPrint(file.get_content)
end function
COMMANDS.regCmd("whoami")
COMMANDS["whoami"].execute = function(args)
    globals.UTILS.cliPrint(globals.USER_NAME)
end function
COMMANDS.regCmd("rm")
COMMANDS["rm"].parser.addValue("file_path", "file path")
COMMANDS["rm"].parser.addFlag("-r", "remove directory")
COMMANDS["rm"].execute = function(args)
    args = globals.COMMANDS["rm"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    file_path = globals.UTILS.resolvePath(args["file_path"])
    file = globals.UTILS.getFile(globals.SHELL, file_path, args["-r"])
    if typeof(file) == "string" then
        return file
    end if

    if not file.has_permission("w") then 
        globals.UTILS.cliPrint("Permission denied: " + file.path)
        return
    end if
    file.delete
end function
COMMANDS.regCmd("clear", "clear terminal output")
COMMANDS["clear"].execute = function(args)
    clear_screen
end function
COMMANDS.regCmd("chmod")
COMMANDS["chmod"].parser.addValue("mode", "u,g,o+wrx")
COMMANDS["chmod"].parser.addValue("file_path", "file path")
COMMANDS["chmod"].parser.addFlag("-r", "is recursive")
COMMANDS["chmod"].execute = function(args)
    args = globals.COMMANDS["chmod"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    file_path = globals.UTILS.resolvePath(args["file_path"])
    file = globals.UTILS.getFile(globals.SHELL, file_path, null)
    if typeof(file) == "string" then
        return file
    end if

    result = file.chmod(args["mode"], args["-r"])
    if typeof(result) == "string" then
        globals.UTILS.cliPrint(result)
    else
        return "Permission denied"
    end if
end function
COMMANDS.regCmd("su", "switch user")
COMMANDS["su"].parser.addValue("user", "user name", "root")
COMMANDS["su"].execute = function(args)
    args = globals.COMMANDS["su"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    pub_ip = globals.SHELL.host_computer.public_ip
    loc_ip = globals.SHELL.host_computer.local_ip

    // try cached shell
    shells = globals.SCAN_CACHE.getShell(pub_ip, loc_ip)
    for shell in shells
        username = globals.UTILS.getUser(shell)
        if username == args["user"] then
            globals.UTILS.useShell(shell)
            return
        end if
    end for

    if globals.UTILS.isHost then
        // try cached passwd
        users = globals.SCAN_CACHE.getUser(pub_ip, loc_ip)
        for user in users
            if user["key"] == args["user"] then
                if user["value"].matches("^[a-fA-F0-9]{32}$").len != 0 then
                    passwd = globals.CRYPTO_LIB.decipher(user["value"])
                    globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]] = passwd
                else
                    passwd = globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]]
                end if
                shell = get_shell(args["user"], passwd)
                if shell then 
                    globals.SCAN_CACHE[pub_ip][loc_ip]["shell"].push(shell)
                    globals.UTILS.useShell(shell)
                    return
                else
                    globals.SCAN_CACHE[pub_ip][loc_ip]["user"].remove(user["key"])
                end if
                break
            end if
        end for

        // use input passwd
        passwd = globals.UTILS.cliInput("Password: ", true)
        target_shell = get_shell(args["user"], passwd)
        if not target_shell then 
            return "Authentication failure"
        end if

        if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
            globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
        end if
        globals.SCAN_CACHE[pub_ip][loc_ip]["user"][args["user"]] = passwd 
        globals.SCAN_CACHE[pub_ip][loc_ip]["shell"].push(target_shell) 
        globals.UTILS.useShell(target_shell)
        return
    else
        // try cached passwd
        users = globals.SCAN_CACHE.getUser(pub_ip, loc_ip)
        for user in users
            if user["key"] == args["user"] then
                if user["value"].matches("^[a-fA-F0-9]{32}$").len != 0 then
                    passwd = globals.CRYPTO_LIB.decipher(user["value"])
                    globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]] = passwd
                else
                    passwd = globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]]
                end if
                jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, ["su", args["user"], passwd])
                if typeof(jump) == "string" then
                    return jump
                else if typeof(jump) == "shell" then 
                    globals.SCAN_CACHE[pub_ip][loc_ip]["shell"].push(jump)
                    globals.UTILS.useShell(jump)
                    return
                else
                    globals.SCAN_CACHE[pub_ip][loc_ip]["user"].remove(user["key"])
                end if
                break
            end if
        end for
        // use input passwd
        passwd = globals.UTILS.cliInput("Password: ", true)
        jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, ["su", args["user"], passwd])
        if typeof(jump) == "string" then
            return jump
        end if

        if typeof(jump) == "shell" then
            globals.UTILS.useShell(jump)
        else
            globals.UTILS.cliPrint("Authentication failure")
            if globals.USER_NAME == "guest" then
                confirm = globals.UTILS.cliInput("Exploit local lib?[y/n]: ", false, true)
                if confirm == "y" then
                    jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, ["lib"])
                    if typeof(jump) == "string" then
                        return jump
                    end if
                    for lib in jump // unsafe indexes
                        libName = lib.lib_name
                        libVersion = lib.version
                        globals.SCAN_CACHE.syncLib(pub_ip, loc_ip, lib)
                        globals.UTILS.cliPrint(libName + " " + libVersion)
                        if not globals.METAX_CACHE.hasLib(libName, libVersion) then
                            for address in globals.METAX_LIB.scan(lib)
                                info = globals.METAX_LIB.scan_address(lib, address).split("Unsafe check: ").replace(char(10), "")
                                for info_line in info
                                    if info_line == info[0] then
                                        continue
                                    end if
                                    zone = info_line[info_line.indexOf("<b>")+3:info_line.indexOf("</b>")]
                                    globals.METAX_CACHE.syncVulner(libName, libVersion, address, zone)
                                end for
                            end for
                        end if
                        for vulner in globals.METAX_CACHE.getVulner(libName, libVersion)
                            address = vulner["key"]
                            zone = vulner["value"]
                            flow = lib.overflow(address, zone)
                            if typeof(flow) != "shell" and typeof(flow) != "computer" and typeof(flow) != "file" then
                                flow = lib.overflow(address, zone, loc_ip)
                            end if
                            globals.SCAN_CACHE.syncItem(pub_ip, loc_ip, flow)
                        end for
                    end for
                end if
            else
                if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
                    globals.SCAN_CACHE.syncMachine(pub_ip, loc_ip)
                end if
                flag = true
                for shell in globals.SCAN_CACHE[pub_ip][loc_ip]["shell"]
                    if globals.UTILS.getPermission(shell) != "guest" then
                        flag = false
                        break
                    end if
                end for
                if flag then
                    globals.SCAN_CACHE.syncItem(pub_ip, loc_ip, globals.SHELL)
                end if
            end if

            globals.SCAN_CACHE.grabUser(pub_ip, loc_ip)
            for user in globals.SCAN_CACHE[pub_ip][loc_ip]["user"]
                if user["key"] == args["user"] then
                    if user["value"].matches("^[a-fA-F0-9]{32}$").len != 0 then
                        passwd = globals.CRYPTO_LIB.decipher(user["value"])
                        globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]] = passwd
                    else
                        passwd = globals.SCAN_CACHE[pub_ip][loc_ip]["user"][user["key"]]
                    end if
                    jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, ["su", args["user"], passwd])
                    if typeof(jump) == "string" then
                        return jump
                    else if typeof(jump) == "shell" then
                        globals.UTILS.useShell(jump)
                        return
                    else
                        return "Failed to crack password"
                    end if
                end if
            end for
            return "No exploit"
        end if
    end if

end function
COMMANDS.regCmd("exit", "back to previous shell")
COMMANDS["exit"].execute = function(args)
    if globals.USED_SHELL.len < 1 then
        confirm = globals.UTILS.cliInput("Exit p1an0Xalpha?[y/n]: ", false, true)
        if confirm == "y" then
            exit
        end if
        return
    end if
    globals.UTILS.exitShell()
end function
COMMANDS.regCmd("env", "show all environment variables")
COMMANDS["env"].execute = function(args)
    for each_var in globals.ENV_VAR.indexes
        globals.UTILS.cliPrint(each_var + "=" + globals.ENV_VAR[each_var])
    end for
end function
COMMANDS.regCmd("export", "add environment variable")
COMMANDS["export"].parser.addValue("var", "variable")
COMMANDS["export"].parser.addValue("value", "value")
COMMANDS["export"].execute = function(args)
    args = globals.COMMANDS["export"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    globals.ENV_VAR[args["var"]] = args["value"]
end function
COMMANDS.regCmd("unset", "remove environment variable")
COMMANDS["unset"].parser.addValue("var", "variable")
COMMANDS["unset"].execute = function(args)
    args = globals.COMMANDS["unset"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    if globals.ENV_VAR.hasIndex(args["var"]) then
        globals.ENV_VAR.remove(args["var"])
    end if
end function
COMMANDS.regCmd("echo")
COMMANDS["echo"].parser.addValue("value", "value")
COMMANDS["echo"].execute = function(args)
    args = globals.COMMANDS["echo"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    globals.UTILS.cliPrint(args["value"])
end function
COMMANDS.regCmd("ifconfig")
COMMANDS["ifconfig"].execute = function(args)
    computer = globals.SHELL.host_computer
    devices = computer.network_devices
    devices_split = devices.split(char(10))[:-1]
    for item in devices_split
        item_split = item.split(" ")
        flag = ""
        if item_split[2] then
            flag = "MONITOR"
        end if
        globals.UTILS.cliPrint(item_split[0] + ": flags=<" + flag + ">")
        globals.UTILS.cliPrint("  inet " + computer.local_ip + "  gateway " + computer.network_gateway)
        globals.UTILS.cliPrint("  inet " + computer.public_ip)
        globals.UTILS.cliPrint("  chipset " + item_split[1])
    end for
    
end function
COMMANDS.regCmd("decipher")
COMMANDS["decipher"].parser.addValue("md5", "md5 hash")
COMMANDS["decipher"].execute = function(args)
    args = globals.COMMANDS["decipher"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if

    resutl = globals.CRYPTO_LIB.decipher(args["md5"])
    if not resutl then
        return "Invalid md5 hash"
    else
        globals.UTILS.cliPrint(resutl)
    end if
end function
COMMANDS.regCmd("terminal")
COMMANDS["terminal"].execute = function(args)
    globals.SHELL.start_terminal
end function
// system commands end
// hack commands begin
COMMANDS.regCmd("scan", "scan target router and cache result")
COMMANDS["scan"].parser.addValue("ip", "router ip", "")
COMMANDS["scan"].execute = function(args)
    args = globals.COMMANDS["scan"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    if args["ip"].len > 0 and not is_valid_ip(args["ip"]) then
        return "Invalid ip"
    end if

    if globals.UTILS.isHost then
        if args["ip"].len == 0 then
            router = get_router
        else
            router = get_router(args["ip"])
        end if
        if not router then
            return "Connection failure"
        end if
        result = {}
        for ip in router.devices_lan_ip
            result[ip] = {}
            ports = router.device_ports(ip)
            if typeof(ports) == "list" then
                for port in ports
                    port_num = port.port_number
                    net_session = globals.METAX_LIB.net_use(ip, port_num)
                    if not net_session then
                        continue
                    end if
                    if port.get_lan_ip == ip then
                        result[ip][port_num] = net_session
                    else
                        if not result.hasIndex(port.get_lan_ip) then
                            result[port.get_lan_ip] = {}
                        end if
                        result[port.get_lan_ip][port_num] = net_session
                    end if
                end for
            end if
        end for
        result[router.local_ip][0] = globals.METAX_LIB.net_use(router.local_ip, 0)
    else
        jump = globals.UTILS.useJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME, ["scan", args["ip"]])
        if typeof(jump) == "string" then
            return jump
        end if
        if jump == null then
            return "Connection failure"
        end if
        router = jump["router"]
        result = jump["result"]
    end if

    pub_ip = router.public_ip
    loc_ip = router.local_ip
    for ip in result.indexes
        for port_num in result[ip].indexes
            globals.SCAN_CACHE.syncSession(pub_ip, ip, port_num, result[ip][port_num])
        end for
    end for
    globals.UTILS.cliPrint("router:")
    globals.UTILS.cliPrint("  public ip: " + pub_ip)
    globals.UTILS.cliPrint("  local  ip: " + loc_ip)
    globals.UTILS.cliPrint("devices:")
    for ip in globals.SCAN_CACHE[pub_ip].indexes
        globals.UTILS.cliPrint("  " + ip + ": ")
        for port in globals.SCAN_CACHE[pub_ip][ip]["port"]
            globals.UTILS.cliPrint("    " + port["key"] + " " + port["value"].dump_lib.lib_name + " " + port["value"].dump_lib.version)
        end for
    end for
end function
COMMANDS.regCmd("hack", "exploit net_session or meta_lib")
COMMANDS["hack"].parser.addValue("local_ip", "local ip")
COMMANDS["hack"].parser.addValue("public_ip", "public ip", "")
COMMANDS["hack"].execute = function(args)
    args = globals.COMMANDS["hack"]["parser"].parse(args)
    if typeof(args) == "string" then
        return args
    end if
    
    pub_ip = args["public_ip"]
    if pub_ip.len == 0 then
        pub_ip = globals.SHELL.host_computer.public_ip
    end if
    loc_ip = args["local_ip"]
    if not is_valid_ip(pub_ip) or is_lan_ip(pub_ip) then
        return "Invalid public ip"
    end if
    if not is_lan_ip(loc_ip) then
        return "Invalid local ip"
    end if
    if not globals.SCAN_CACHE.hasMachine(pub_ip, loc_ip) then
        return "Scan cache not found"
    end if

    meta_libs = globals.SCAN_CACHE[pub_ip][loc_ip]["port"].values + globals.SCAN_CACHE[pub_ip][loc_ip]["lib"]
    if meta_libs.len == 0 then
        return "No open port or local lib"
    end if
    for lib in meta_libs
        if typeof(lib) == "NetSession" then
            lib = lib.dump_lib
        end if
        libName = lib.lib_name
        libVersion = lib.version
        globals.UTILS.cliPrint(libName + " " + libVersion)

        if not globals.METAX_CACHE.hasLib(libName, libVersion) then
            for address in globals.METAX_LIB.scan(lib)
                info = globals.METAX_LIB.scan_address(lib, address).split("Unsafe check: ").replace(char(10), "")
                for info_line in info
                    if info_line == info[0] then continue
                    zone = info_line[info_line.indexOf("<b>")+3:info_line.indexOf("</b>")]
                    globals.METAX_CACHE.syncVulner(libName, libVersion, address, zone)
                end for
            end for
        end if

        for each_vulner in globals.METAX_CACHE.getVulner(libName, libVersion)
            address = each_vulner["key"]
            zone = each_vulner["value"]
            flow = lib.overflow(address, zone)
            if typeof(flow) != "shell" and typeof(flow) != "computer" and typeof(flow) != "file" then
                flow = lib.overflow(address, zone, loc_ip)
            end if
            globals.SCAN_CACHE.syncItem(pub_ip, loc_ip, flow)
        end for
    end for

    globals.SCAN_CACHE.grabUser(pub_ip, loc_ip)
    globals.SCAN_CACHE.grabBank(pub_ip, loc_ip)
    shells = globals.SCAN_CACHE[pub_ip][loc_ip]["shell"]
    mails = globals.SCAN_CACHE[pub_ip][loc_ip]["mail"]
    
    if shells.len == 0 and mails.len > 0 then
        globals.UTILS.cliPrint("mail: ")
        for mail in mails
            globals.UTILS.cliPrint("  " + mail["key"] + " " + mail["value"])
        end for
    else if shells.len > 0 then
        globals.UTILS.cliPrint("shell: ")
        for index in shells.indexes
            shell = shells[index]
            user = globals.UTILS.getUser(shell)
            globals.UTILS.cliPrint("  " + index + ")" + user)
        end for
        use = to_int(globals.UTILS.cliInput("use: "))
        if typeof(use) == "number" or use >= 0 and use < shells.len then
            globals.UTILS.useShell(shells[use])
        end if
    else
        return "No exploit"
    end if
end function
COMMANDS.regCmd("jump", "make jumpfile on target shell")
COMMANDS["jump"].execute = function(args)
    jump = globals.UTILS.makeJumpfile(globals.SHELL, globals.ENV_VAR.JUMP_PATH, globals.ENV_VAR.JUMP_NAME)
    if typeof(jump) == "string" then
        return jump
    end if
    upload = scp(get_shell, globals.METAX_PATH, jump_path, globals.SHELL)
    if upload != true then
        return upload
    end if
end function
// hack commands end
// commands end
// main loop begin
getInput = function()
    suffix = "$"
    show_path = globals.WORK_DIR[:len(globals.HOME_DIR)].replace(globals.HOME_DIR, "~") + globals.WORK_DIR[len(globals.HOME_DIR):]
    if globals.USER_NAME == "root" then
        suffix = "#"
        show_path = globals.WORK_DIR
    end if
    output = char(10)+globals.COLOR.SHELL_BAR+"<pos=05>———(</color><b>"+globals.COLOR.SHELL_USER+globals.USER_NAME+"@"+globals.HOST_NAME+"</color></b>"+globals.COLOR.SHELL_BAR+")—[</color><b>"+globals.COLOR.SHELL_PATH+show_path+"</b>"+globals.COLOR.SHELL_BAR+"]<voffset=-0.5em>"+"<pos=00>|<voffset=-1em><space=-0.6em>|<voffset=-1.5em><pos=05>——<b></color>"+globals.COLOR.SHELL_USER+suffix+"</color></b>"+globals.COLOR.SHELL_INPUT+" "
    return user_input(output)
end function
executeCommand = function(command, arguments)
    if not globals.COMMANDS.hasIndex(command) then
        return "Command '"+command+"' not found"
    end if
    return globals.COMMANDS[command].execute(arguments)
end function
while true
    input = getInput
    if not input then continue

    parsed_input = globals.CLIPARSER.parse(input)
    execute_result = executeCommand(parsed_input[0], parsed_input[1:])
    if typeof(execute_result) == "string" then
        globals.UTILS.cliPrint(execute_result)
    end if
end while
// main loop end